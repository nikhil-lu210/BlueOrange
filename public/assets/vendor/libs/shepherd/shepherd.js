/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/shepherd/shepherd.js":
/*!***********************************!*\
  !*** ./libs/shepherd/shepherd.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shepherd: function() { return /* reexport default from dynamic */ shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shepherd.js/dist/js/shepherd */ \"./node_modules/shepherd.js/dist/js/shepherd.js\");\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n//# sourceURL=webpack://Vuexy/./libs/shepherd/shepherd.js?");

/***/ }),

/***/ "./node_modules/shepherd.js/dist/js/shepherd.js":
/*!******************************************************!*\
  !*** ./node_modules/shepherd.js/dist/js/shepherd.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*! shepherd.js 11.1.1 */\n\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict';\n\n  var isMergeableObject = function isMergeableObject(value) {\n    return isNonNullObject(value) && !isSpecial(value);\n  };\n  function isNonNullObject(value) {\n    return !!value && _typeof(value) === 'object';\n  }\n  function isSpecial(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);\n  }\n\n  // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n  function isReactElement(value) {\n    return value.$$typeof === REACT_ELEMENT_TYPE;\n  }\n  function emptyTarget(val) {\n    return Array.isArray(val) ? [] : {};\n  }\n  function cloneUnlessOtherwiseSpecified(value, options) {\n    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;\n  }\n  function defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function (element) {\n      return cloneUnlessOtherwiseSpecified(element, options);\n    });\n  }\n  function getMergeFunction(key, options) {\n    if (!options.customMerge) {\n      return deepmerge;\n    }\n    var customMerge = options.customMerge(key);\n    return typeof customMerge === 'function' ? customMerge : deepmerge;\n  }\n  function getEnumerableOwnPropertySymbols(target) {\n    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n      return Object.propertyIsEnumerable.call(target, symbol);\n    }) : [];\n  }\n  function getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n  }\n  function propertyIsOnObject(object, property) {\n    try {\n      return property in object;\n    } catch (_) {\n      return false;\n    }\n  }\n\n  // Protects from prototype poisoning and unexpected merging up the prototype chain.\n  function propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n  }\n\n  function mergeObject(target, source, options) {\n    var destination = {};\n    if (options.isMergeableObject(target)) {\n      getKeys(target).forEach(function (key) {\n        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n      });\n    }\n    getKeys(source).forEach(function (key) {\n      if (propertyIsUnsafe(target, key)) {\n        return;\n      }\n      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n      } else {\n        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n      }\n    });\n    return destination;\n  }\n  function deepmerge(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n    options.isMergeableObject = options.isMergeableObject || isMergeableObject;\n    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n    if (!sourceAndTargetTypesMatch) {\n      return cloneUnlessOtherwiseSpecified(source, options);\n    } else if (sourceIsArray) {\n      return options.arrayMerge(target, source, options);\n    } else {\n      return mergeObject(target, source, options);\n    }\n  }\n  deepmerge.all = function deepmergeAll(array, options) {\n    if (!Array.isArray(array)) {\n      throw new Error('first argument should be an array');\n    }\n    return array.reduce(function (prev, next) {\n      return deepmerge(prev, next, options);\n    }, {});\n  };\n  var deepmerge_1 = deepmerge;\n  var cjs = deepmerge_1;\n\n  /**\n   * Checks if `value` is classified as an `Element`.\n   * @param {*} value The param to check if it is an Element\n   */\n  function isElement$1(value) {\n    return value instanceof Element;\n  }\n\n  /**\n   * Checks if `value` is classified as an `HTMLElement`.\n   * @param {*} value The param to check if it is an HTMLElement\n   */\n  function isHTMLElement$1(value) {\n    return value instanceof HTMLElement;\n  }\n\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   * @param {*} value The param to check if it is a function\n   */\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n\n  /**\n   * Checks if `value` is classified as a `String` object.\n   * @param {*} value The param to check if it is a string\n   */\n  function isString(value) {\n    return typeof value === 'string';\n  }\n\n  /**\n   * Checks if `value` is undefined.\n   * @param {*} value The param to check if it is undefined\n   */\n  function isUndefined(value) {\n    return value === undefined;\n  }\n  var Evented = /*#__PURE__*/function () {\n    function Evented() {\n      _classCallCheck(this, Evented);\n    }\n    _createClass(Evented, [{\n      key: \"on\",\n      value: function on(event, handler, ctx, once) {\n        if (once === void 0) {\n          once = false;\n        }\n        if (isUndefined(this.bindings)) {\n          this.bindings = {};\n        }\n        if (isUndefined(this.bindings[event])) {\n          this.bindings[event] = [];\n        }\n        this.bindings[event].push({\n          handler: handler,\n          ctx: ctx,\n          once: once\n        });\n        return this;\n      }\n    }, {\n      key: \"once\",\n      value: function once(event, handler, ctx) {\n        return this.on(event, handler, ctx, true);\n      }\n    }, {\n      key: \"off\",\n      value: function off(event, handler) {\n        var _this = this;\n        if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n          return this;\n        }\n        if (isUndefined(handler)) {\n          delete this.bindings[event];\n        } else {\n          this.bindings[event].forEach(function (binding, index) {\n            if (binding.handler === handler) {\n              _this.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }, {\n      key: \"trigger\",\n      value: function trigger(event) {\n        var _this2 = this;\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        if (!isUndefined(this.bindings) && this.bindings[event]) {\n          this.bindings[event].forEach(function (binding, index) {\n            var ctx = binding.ctx,\n              handler = binding.handler,\n              once = binding.once;\n            var context = ctx || _this2;\n            handler.apply(context, args);\n            if (once) {\n              _this2.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }]);\n    return Evented;\n  }();\n  /**\n   * Binds all the methods on a JS Class to the `this` context of the class.\n   * Adapted from https://github.com/sindresorhus/auto-bind\n   * @param {object} self The `this` context of the class\n   * @return {object} The `this` context of the class\n   */\n  function autoBind(self) {\n    var keys = Object.getOwnPropertyNames(self.constructor.prototype);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = self[key];\n      if (key !== 'constructor' && typeof val === 'function') {\n        self[key] = val.bind(self);\n      }\n    }\n    return self;\n  }\n\n  /**\n   * Sets up the handler to determine if we should advance the tour\n   * @param {string} selector\n   * @param {Step} step The step instance\n   * @return {Function}\n   * @private\n   */\n  function _setupAdvanceOnHandler(selector, step) {\n    return function (event) {\n      if (step.isOpen()) {\n        var targetIsEl = step.el && event.currentTarget === step.el;\n        var targetIsSelector = !isUndefined(selector) && event.currentTarget.matches(selector);\n        if (targetIsSelector || targetIsEl) {\n          step.tour.next();\n        }\n      }\n    };\n  }\n\n  /**\n   * Bind the event handler for advanceOn\n   * @param {Step} step The step instance\n   */\n  function bindAdvance(step) {\n    // An empty selector matches the step element\n    var _ref2 = step.options.advanceOn || {},\n      event = _ref2.event,\n      selector = _ref2.selector;\n    if (event) {\n      var handler = _setupAdvanceOnHandler(selector, step);\n\n      // TODO: this should also bind/unbind on show/hide\n      var el;\n      try {\n        el = document.querySelector(selector);\n      } catch (e) {\n        // TODO\n      }\n      if (!isUndefined(selector) && !el) {\n        return console.error(\"No element was found for the selector supplied to advanceOn: \".concat(selector));\n      } else if (el) {\n        el.addEventListener(event, handler);\n        step.on('destroy', function () {\n          return el.removeEventListener(event, handler);\n        });\n      } else {\n        document.body.addEventListener(event, handler, true);\n        step.on('destroy', function () {\n          return document.body.removeEventListener(event, handler, true);\n        });\n      }\n    } else {\n      return console.error('advanceOn was defined, but no event name was passed.');\n    }\n  }\n\n  /**\n   * Ensure class prefix ends in `-`\n   * @param {string} prefix The prefix to prepend to the class names generated by nano-css\n   * @return {string} The prefix ending in `-`\n   */\n  function normalizePrefix(prefix) {\n    if (!isString(prefix) || prefix === '') {\n      return '';\n    }\n    return prefix.charAt(prefix.length - 1) !== '-' ? \"\".concat(prefix, \"-\") : prefix;\n  }\n\n  /**\n   * Resolves attachTo options, converting element option value to a qualified HTMLElement.\n   * @param {Step} step The step instance\n   * @returns {{}|{element, on}}\n   * `element` is a qualified HTML Element\n   * `on` is a string position value\n   */\n  function parseAttachTo(step) {\n    var options = step.options.attachTo || {};\n    var returnOpts = Object.assign({}, options);\n    if (isFunction(returnOpts.element)) {\n      // Bind the callback to step so that it has access to the object, to enable running additional logic\n      returnOpts.element = returnOpts.element.call(step);\n    }\n    if (isString(returnOpts.element)) {\n      // Can't override the element in user opts reference because we can't\n      // guarantee that the element will exist in the future.\n      try {\n        returnOpts.element = document.querySelector(returnOpts.element);\n      } catch (e) {\n        // TODO\n      }\n      if (!returnOpts.element) {\n        console.error(\"The element for this Shepherd step was not found \".concat(options.element));\n      }\n    }\n    return returnOpts;\n  }\n\n  /**\n   * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure\n   * alternative for the deprecated step.isCentered() method.\n   * @param resolvedAttachToOptions\n   * @returns {boolean}\n   */\n  function shouldCenterStep(resolvedAttachToOptions) {\n    if (resolvedAttachToOptions === undefined || resolvedAttachToOptions === null) {\n      return true;\n    }\n    return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;\n  }\n\n  /**\n   * Create a unique id for steps, tours, modals, etc\n   * @return {string}\n   */\n  function uuid() {\n    var d = Date.now();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n  }\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n    return target;\n  }\n  var _excluded2 = [\"mainAxis\", \"crossAxis\", \"fallbackPlacements\", \"fallbackStrategy\", \"fallbackAxisSideDirection\", \"flipAlignment\"],\n    _excluded4 = [\"mainAxis\", \"crossAxis\", \"limiter\"];\n  function getAlignment(placement) {\n    return placement.split('-')[1];\n  }\n  function getLengthFromAxis(axis) {\n    return axis === 'y' ? 'height' : 'width';\n  }\n  function getSide(placement) {\n    return placement.split('-')[0];\n  }\n  function getMainAxisFromPlacement(placement) {\n    return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n  }\n  function computeCoordsFromPlacement(_ref, placement, rtl) {\n    var reference = _ref.reference,\n      floating = _ref.floating;\n    var commonX = reference.x + reference.width / 2 - floating.width / 2;\n    var commonY = reference.y + reference.height / 2 - floating.height / 2;\n    var mainAxis = getMainAxisFromPlacement(placement);\n    var length = getLengthFromAxis(mainAxis);\n    var commonAlign = reference[length] / 2 - floating[length] / 2;\n    var side = getSide(placement);\n    var isVertical = mainAxis === 'x';\n    var coords;\n    switch (side) {\n      case 'top':\n        coords = {\n          x: commonX,\n          y: reference.y - floating.height\n        };\n        break;\n      case 'bottom':\n        coords = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n      case 'right':\n        coords = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n      case 'left':\n        coords = {\n          x: reference.x - floating.width,\n          y: commonY\n        };\n        break;\n      default:\n        coords = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n    switch (getAlignment(placement)) {\n      case 'start':\n        coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n        break;\n      case 'end':\n        coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n        break;\n    }\n    return coords;\n  }\n\n  /**\n   * Computes the `x` and `y` coordinates that will place the floating element\n   * next to a reference element when it is given a certain positioning strategy.\n   *\n   * This export does not have any `platform` interface logic. You will need to\n   * write one for the platform you are using Floating UI with.\n   */\n  var computePosition$1 = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(reference, floating, config) {\n      var _config$placement, placement, _config$strategy, strategy, _config$middleware, middleware, platform, validMiddleware, rtl, rects, _computeCoordsFromPla, x, y, statefulPlacement, middlewareData, resetCount, i, _validMiddleware$i, name, fn, _yield$fn, nextX, nextY, data, reset, _computeCoordsFromPla2;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _config$placement = config.placement, placement = _config$placement === void 0 ? 'bottom' : _config$placement, _config$strategy = config.strategy, strategy = _config$strategy === void 0 ? 'absolute' : _config$strategy, _config$middleware = config.middleware, middleware = _config$middleware === void 0 ? [] : _config$middleware, platform = config.platform;\n            validMiddleware = middleware.filter(Boolean);\n            _context.next = 4;\n            return platform.isRTL == null ? void 0 : platform.isRTL(floating);\n          case 4:\n            rtl = _context.sent;\n            _context.next = 7;\n            return platform.getElementRects({\n              reference: reference,\n              floating: floating,\n              strategy: strategy\n            });\n          case 7:\n            rects = _context.sent;\n            _computeCoordsFromPla = computeCoordsFromPlacement(rects, placement, rtl), x = _computeCoordsFromPla.x, y = _computeCoordsFromPla.y;\n            statefulPlacement = placement;\n            middlewareData = {};\n            resetCount = 0;\n            i = 0;\n          case 13:\n            if (!(i < validMiddleware.length)) {\n              _context.next = 46;\n              break;\n            }\n            _validMiddleware$i = validMiddleware[i], name = _validMiddleware$i.name, fn = _validMiddleware$i.fn;\n            _context.next = 17;\n            return fn({\n              x: x,\n              y: y,\n              initialPlacement: placement,\n              placement: statefulPlacement,\n              strategy: strategy,\n              middlewareData: middlewareData,\n              rects: rects,\n              platform: platform,\n              elements: {\n                reference: reference,\n                floating: floating\n              }\n            });\n          case 17:\n            _yield$fn = _context.sent;\n            nextX = _yield$fn.x;\n            nextY = _yield$fn.y;\n            data = _yield$fn.data;\n            reset = _yield$fn.reset;\n            x = nextX != null ? nextX : x;\n            y = nextY != null ? nextY : y;\n            middlewareData = _extends({}, middlewareData, _defineProperty({}, name, _extends({}, middlewareData[name], data)));\n            if (!(reset && resetCount <= 50)) {\n              _context.next = 43;\n              break;\n            }\n            resetCount++;\n            if (!(_typeof(reset) === 'object')) {\n              _context.next = 41;\n              break;\n            }\n            if (reset.placement) {\n              statefulPlacement = reset.placement;\n            }\n            if (!reset.rects) {\n              _context.next = 38;\n              break;\n            }\n            if (!(reset.rects === true)) {\n              _context.next = 36;\n              break;\n            }\n            _context.next = 33;\n            return platform.getElementRects({\n              reference: reference,\n              floating: floating,\n              strategy: strategy\n            });\n          case 33:\n            _context.t0 = _context.sent;\n            _context.next = 37;\n            break;\n          case 36:\n            _context.t0 = reset.rects;\n          case 37:\n            rects = _context.t0;\n          case 38:\n            _computeCoordsFromPla2 = computeCoordsFromPlacement(rects, statefulPlacement, rtl);\n            x = _computeCoordsFromPla2.x;\n            y = _computeCoordsFromPla2.y;\n          case 41:\n            i = -1;\n            return _context.abrupt(\"continue\", 43);\n          case 43:\n            i++;\n            _context.next = 13;\n            break;\n          case 46:\n            return _context.abrupt(\"return\", {\n              x: x,\n              y: y,\n              placement: statefulPlacement,\n              strategy: strategy,\n              middlewareData: middlewareData\n            });\n          case 47:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function computePosition$1(_x, _x2, _x3) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  function expandPaddingObject(padding) {\n    return _extends({\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }, padding);\n  }\n  function getSideObjectFromPadding(padding) {\n    return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n      top: padding,\n      right: padding,\n      bottom: padding,\n      left: padding\n    };\n  }\n  function rectToClientRect(rect) {\n    return _extends({}, rect, {\n      top: rect.y,\n      left: rect.x,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n\n  /**\n   * Resolves with an object of overflow side offsets that determine how much the\n   * element is overflowing a given clipping boundary on each side.\n   * - positive = overflowing the boundary by that number of pixels\n   * - negative = how many pixels left before it will overflow\n   * - 0 = lies flush with the boundary\n   * @see https://floating-ui.com/docs/detectOverflow\n   */\n  function detectOverflow(_x4, _x5) {\n    return _detectOverflow.apply(this, arguments);\n  }\n  function _detectOverflow() {\n    _detectOverflow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(state, options) {\n      var _await$platform$isEle, x, y, platform, rects, elements, strategy, _options5, _options5$boundary, boundary, _options5$rootBoundar, rootBoundary, _options5$elementCont, elementContext, _options5$altBoundary, altBoundary, _options5$padding, padding, paddingObject, altContext, element, clippingClientRect, rect, offsetParent, offsetScale, elementClientRect;\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            if (options === void 0) {\n              options = {};\n            }\n            x = state.x, y = state.y, platform = state.platform, rects = state.rects, elements = state.elements, strategy = state.strategy;\n            _options5 = options, _options5$boundary = _options5.boundary, boundary = _options5$boundary === void 0 ? 'clippingAncestors' : _options5$boundary, _options5$rootBoundar = _options5.rootBoundary, rootBoundary = _options5$rootBoundar === void 0 ? 'viewport' : _options5$rootBoundar, _options5$elementCont = _options5.elementContext, elementContext = _options5$elementCont === void 0 ? 'floating' : _options5$elementCont, _options5$altBoundary = _options5.altBoundary, altBoundary = _options5$altBoundary === void 0 ? false : _options5$altBoundary, _options5$padding = _options5.padding, padding = _options5$padding === void 0 ? 0 : _options5$padding;\n            paddingObject = getSideObjectFromPadding(padding);\n            altContext = elementContext === 'floating' ? 'reference' : 'floating';\n            element = elements[altBoundary ? altContext : elementContext];\n            _context7.t0 = rectToClientRect;\n            _context7.t1 = platform;\n            _context7.next = 10;\n            return platform.isElement == null ? void 0 : platform.isElement(element);\n          case 10:\n            _context7.t2 = _await$platform$isEle = _context7.sent;\n            if (!(_context7.t2 != null)) {\n              _context7.next = 15;\n              break;\n            }\n            _context7.t3 = _await$platform$isEle;\n            _context7.next = 16;\n            break;\n          case 15:\n            _context7.t3 = true;\n          case 16:\n            if (!_context7.t3) {\n              _context7.next = 20;\n              break;\n            }\n            _context7.t4 = element;\n            _context7.next = 26;\n            break;\n          case 20:\n            _context7.t5 = element.contextElement;\n            if (_context7.t5) {\n              _context7.next = 25;\n              break;\n            }\n            _context7.next = 24;\n            return platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating);\n          case 24:\n            _context7.t5 = _context7.sent;\n          case 25:\n            _context7.t4 = _context7.t5;\n          case 26:\n            _context7.t6 = _context7.t4;\n            _context7.t7 = boundary;\n            _context7.t8 = rootBoundary;\n            _context7.t9 = strategy;\n            _context7.t10 = {\n              element: _context7.t6,\n              boundary: _context7.t7,\n              rootBoundary: _context7.t8,\n              strategy: _context7.t9\n            };\n            _context7.next = 33;\n            return _context7.t1.getClippingRect.call(_context7.t1, _context7.t10);\n          case 33:\n            _context7.t11 = _context7.sent;\n            clippingClientRect = (0, _context7.t0)(_context7.t11);\n            rect = elementContext === 'floating' ? _extends({}, rects.floating, {\n              x: x,\n              y: y\n            }) : rects.reference;\n            _context7.next = 38;\n            return platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating);\n          case 38:\n            offsetParent = _context7.sent;\n            _context7.next = 41;\n            return platform.isElement == null ? void 0 : platform.isElement(offsetParent);\n          case 41:\n            if (!_context7.sent) {\n              _context7.next = 50;\n              break;\n            }\n            _context7.next = 44;\n            return platform.getScale == null ? void 0 : platform.getScale(offsetParent);\n          case 44:\n            _context7.t13 = _context7.sent;\n            if (_context7.t13) {\n              _context7.next = 47;\n              break;\n            }\n            _context7.t13 = {\n              x: 1,\n              y: 1\n            };\n          case 47:\n            _context7.t12 = _context7.t13;\n            _context7.next = 51;\n            break;\n          case 50:\n            _context7.t12 = {\n              x: 1,\n              y: 1\n            };\n          case 51:\n            offsetScale = _context7.t12;\n            _context7.t14 = rectToClientRect;\n            if (!platform.convertOffsetParentRelativeRectToViewportRelativeRect) {\n              _context7.next = 59;\n              break;\n            }\n            _context7.next = 56;\n            return platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n              rect: rect,\n              offsetParent: offsetParent,\n              strategy: strategy\n            });\n          case 56:\n            _context7.t15 = _context7.sent;\n            _context7.next = 60;\n            break;\n          case 59:\n            _context7.t15 = rect;\n          case 60:\n            _context7.t16 = _context7.t15;\n            elementClientRect = (0, _context7.t14)(_context7.t16);\n            return _context7.abrupt(\"return\", {\n              top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n              bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n              left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n              right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n            });\n          case 63:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7);\n    }));\n    return _detectOverflow.apply(this, arguments);\n  }\n  var min$1 = Math.min;\n  var max$1 = Math.max;\n  function within(min$1$1, value, max$1$1) {\n    return max$1(min$1$1, min$1(value, max$1$1));\n  }\n\n  /**\n   * Provides data to position an inner element of the floating element so that it\n   * appears centered to the reference element.\n   * @see https://floating-ui.com/docs/arrow\n   */\n  var arrow = function arrow(options) {\n    return {\n      name: 'arrow',\n      options: options,\n      fn: function fn(state) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var _data, _ref5;\n          var _ref4, element, _ref4$padding, padding, x, y, placement, rects, platform, elements, paddingObject, coords, axis, length, arrowDimensions, isYAxis, minProp, maxProp, clientProp, endDiff, startDiff, arrowOffsetParent, clientSize, centerToReference, min, max, center, offset, shouldAddOffset, alignmentOffset;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                // Since `element` is required, we don't Partial<> the type.\n                _ref4 = options || {}, element = _ref4.element, _ref4$padding = _ref4.padding, padding = _ref4$padding === void 0 ? 0 : _ref4$padding;\n                x = state.x, y = state.y, placement = state.placement, rects = state.rects, platform = state.platform, elements = state.elements;\n                if (!(element == null)) {\n                  _context2.next = 4;\n                  break;\n                }\n                return _context2.abrupt(\"return\", {});\n              case 4:\n                paddingObject = getSideObjectFromPadding(padding);\n                coords = {\n                  x: x,\n                  y: y\n                };\n                axis = getMainAxisFromPlacement(placement);\n                length = getLengthFromAxis(axis);\n                _context2.next = 10;\n                return platform.getDimensions(element);\n              case 10:\n                arrowDimensions = _context2.sent;\n                isYAxis = axis === 'y';\n                minProp = isYAxis ? 'top' : 'left';\n                maxProp = isYAxis ? 'bottom' : 'right';\n                clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n                endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n                startDiff = coords[axis] - rects.reference[axis];\n                _context2.next = 19;\n                return platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element);\n              case 19:\n                arrowOffsetParent = _context2.sent;\n                clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0; // DOM platform can return `window` as the `offsetParent`.\n                _context2.t0 = !clientSize;\n                if (_context2.t0) {\n                  _context2.next = 26;\n                  break;\n                }\n                _context2.next = 25;\n                return platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent);\n              case 25:\n                _context2.t0 = !_context2.sent;\n              case 26:\n                if (!_context2.t0) {\n                  _context2.next = 28;\n                  break;\n                }\n                clientSize = elements.floating[clientProp] || rects.floating[length];\n              case 28:\n                centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n                // point is outside the floating element's bounds.\n                min = paddingObject[minProp];\n                max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n                center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n                offset = within(min, center, max); // If the reference is small enough that the arrow's padding causes it to\n                // to point to nothing for an aligned placement, adjust the offset of the\n                // floating element itself. This stops `shift()` from taking action, but can\n                // be worked around by calling it again after the `arrow()` if desired.\n                shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;\n                alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n                return _context2.abrupt(\"return\", (_ref5 = {}, _defineProperty(_ref5, axis, coords[axis] - alignmentOffset), _defineProperty(_ref5, \"data\", (_data = {}, _defineProperty(_data, axis, offset), _defineProperty(_data, \"centerOffset\", center - offset), _data)), _ref5));\n              case 36:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }))();\n      }\n    };\n  };\n  var oppositeSideMap = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (side) {\n      return oppositeSideMap[side];\n    });\n  }\n  function getAlignmentSides(placement, rects, rtl) {\n    if (rtl === void 0) {\n      rtl = false;\n    }\n    var alignment = getAlignment(placement);\n    var mainAxis = getMainAxisFromPlacement(placement);\n    var length = getLengthFromAxis(mainAxis);\n    var mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n    if (rects.reference[length] > rects.floating[length]) {\n      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n    }\n    return {\n      main: mainAlignmentSide,\n      cross: getOppositePlacement(mainAlignmentSide)\n    };\n  }\n  var oppositeAlignmentMap = {\n    start: 'end',\n    end: 'start'\n  };\n  function getOppositeAlignmentPlacement(placement) {\n    return placement.replace(/start|end/g, function (alignment) {\n      return oppositeAlignmentMap[alignment];\n    });\n  }\n  function getExpandedPlacements(placement) {\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n  }\n  function getSideList(side, isStart, rtl) {\n    var lr = ['left', 'right'];\n    var rl = ['right', 'left'];\n    var tb = ['top', 'bottom'];\n    var bt = ['bottom', 'top'];\n    switch (side) {\n      case 'top':\n      case 'bottom':\n        if (rtl) return isStart ? rl : lr;\n        return isStart ? lr : rl;\n      case 'left':\n      case 'right':\n        return isStart ? tb : bt;\n      default:\n        return [];\n    }\n  }\n  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n    var alignment = getAlignment(placement);\n    var list = getSideList(getSide(placement), direction === 'start', rtl);\n    if (alignment) {\n      list = list.map(function (side) {\n        return side + \"-\" + alignment;\n      });\n      if (flipAlignment) {\n        list = list.concat(list.map(getOppositeAlignmentPlacement));\n      }\n    }\n    return list;\n  }\n\n  /**\n   * Optimizes the visibility of the floating element by flipping the `placement`\n   * in order to keep it in view when the preferred placement(s) will overflow the\n   * clipping boundary. Alternative to `autoPlacement`.\n   * @see https://floating-ui.com/docs/flip\n   */\n  var flip = function flip(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      name: 'flip',\n      options: options,\n      fn: function fn(state) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n          var _middlewareData$flip, placement, middlewareData, rects, initialPlacement, platform, elements, _options, _options$mainAxis, checkMainAxis, _options$crossAxis, checkCrossAxis, specifiedFallbackPlacements, _options$fallbackStra, fallbackStrategy, _options$fallbackAxis, fallbackAxisSideDirection, _options$flipAlignmen, flipAlignment, detectOverflowOptions, side, isBasePlacement, rtl, fallbackPlacements, placements, overflow, overflows, overflowsData, _getAlignmentSides, main, cross, _middlewareData$flip2, _overflowsData$filter, nextIndex, nextPlacement, resetPlacement, _overflowsData$map$so, _placement;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                placement = state.placement, middlewareData = state.middlewareData, rects = state.rects, initialPlacement = state.initialPlacement, platform = state.platform, elements = state.elements;\n                _options = options, _options$mainAxis = _options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$crossAxis = _options.crossAxis, checkCrossAxis = _options$crossAxis === void 0 ? true : _options$crossAxis, specifiedFallbackPlacements = _options.fallbackPlacements, _options$fallbackStra = _options.fallbackStrategy, fallbackStrategy = _options$fallbackStra === void 0 ? 'bestFit' : _options$fallbackStra, _options$fallbackAxis = _options.fallbackAxisSideDirection, fallbackAxisSideDirection = _options$fallbackAxis === void 0 ? 'none' : _options$fallbackAxis, _options$flipAlignmen = _options.flipAlignment, flipAlignment = _options$flipAlignmen === void 0 ? true : _options$flipAlignmen, detectOverflowOptions = _objectWithoutPropertiesLoose(options, _excluded2);\n                side = getSide(placement);\n                isBasePlacement = getSide(initialPlacement) === initialPlacement;\n                _context3.next = 6;\n                return platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);\n              case 6:\n                rtl = _context3.sent;\n                fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n                if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n                  fallbackPlacements.push.apply(fallbackPlacements, _toConsumableArray(getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl)));\n                }\n                placements = [initialPlacement].concat(_toConsumableArray(fallbackPlacements));\n                _context3.next = 12;\n                return detectOverflow(state, detectOverflowOptions);\n              case 12:\n                overflow = _context3.sent;\n                overflows = [];\n                overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n                if (checkMainAxis) {\n                  overflows.push(overflow[side]);\n                }\n                if (checkCrossAxis) {\n                  _getAlignmentSides = getAlignmentSides(placement, rects, rtl), main = _getAlignmentSides.main, cross = _getAlignmentSides.cross;\n                  overflows.push(overflow[main], overflow[cross]);\n                }\n                overflowsData = [].concat(_toConsumableArray(overflowsData), [{\n                  placement: placement,\n                  overflows: overflows\n                }]);\n\n                // One or more sides is overflowing.\n                if (overflows.every(function (side) {\n                  return side <= 0;\n                })) {\n                  _context3.next = 35;\n                  break;\n                }\n                nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                nextPlacement = placements[nextIndex];\n                if (!nextPlacement) {\n                  _context3.next = 23;\n                  break;\n                }\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    index: nextIndex,\n                    overflows: overflowsData\n                  },\n                  reset: {\n                    placement: nextPlacement\n                  }\n                });\n              case 23:\n                // First, find the candidates that fit on the mainAxis side of overflow,\n                // then find the placement that fits the best on the main crossAxis side.\n                resetPlacement = (_overflowsData$filter = overflowsData.filter(function (d) {\n                  return d.overflows[0] <= 0;\n                }).sort(function (a, b) {\n                  return a.overflows[1] - b.overflows[1];\n                })[0]) == null ? void 0 : _overflowsData$filter.placement; // Otherwise fallback.\n                if (resetPlacement) {\n                  _context3.next = 33;\n                  break;\n                }\n                _context3.t0 = fallbackStrategy;\n                _context3.next = _context3.t0 === 'bestFit' ? 28 : _context3.t0 === 'initialPlacement' ? 31 : 33;\n                break;\n              case 28:\n                _placement = (_overflowsData$map$so = overflowsData.map(function (d) {\n                  return [d.placement, d.overflows.filter(function (overflow) {\n                    return overflow > 0;\n                  }).reduce(function (acc, overflow) {\n                    return acc + overflow;\n                  }, 0)];\n                }).sort(function (a, b) {\n                  return a[1] - b[1];\n                })[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (_placement) {\n                  resetPlacement = _placement;\n                }\n                return _context3.abrupt(\"break\", 33);\n              case 31:\n                resetPlacement = initialPlacement;\n                return _context3.abrupt(\"break\", 33);\n              case 33:\n                if (!(placement !== resetPlacement)) {\n                  _context3.next = 35;\n                  break;\n                }\n                return _context3.abrupt(\"return\", {\n                  reset: {\n                    placement: resetPlacement\n                  }\n                });\n              case 35:\n                return _context3.abrupt(\"return\", {});\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }, _callee3);\n        }))();\n      }\n    };\n  };\n  function getCrossAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n\n  /**\n   * Optimizes the visibility of the floating element by shifting it in order to\n   * keep it in view when it will overflow the clipping boundary.\n   * @see https://floating-ui.com/docs/shift\n   */\n  var shift = function shift(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      name: 'shift',\n      options: options,\n      fn: function fn(state) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n          var _extends3;\n          var x, y, placement, _options2, _options2$mainAxis, checkMainAxis, _options2$crossAxis, checkCrossAxis, _options2$limiter, limiter, detectOverflowOptions, coords, overflow, mainAxis, crossAxis, mainAxisCoord, crossAxisCoord, minSide, maxSide, _min, _max, _minSide, _maxSide, _min2, _max2, limitedCoords;\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) switch (_context4.prev = _context4.next) {\n              case 0:\n                x = state.x, y = state.y, placement = state.placement;\n                _options2 = options, _options2$mainAxis = _options2.mainAxis, checkMainAxis = _options2$mainAxis === void 0 ? true : _options2$mainAxis, _options2$crossAxis = _options2.crossAxis, checkCrossAxis = _options2$crossAxis === void 0 ? false : _options2$crossAxis, _options2$limiter = _options2.limiter, limiter = _options2$limiter === void 0 ? {\n                  fn: function fn(_ref) {\n                    var x = _ref.x,\n                      y = _ref.y;\n                    return {\n                      x: x,\n                      y: y\n                    };\n                  }\n                } : _options2$limiter, detectOverflowOptions = _objectWithoutPropertiesLoose(options, _excluded4);\n                coords = {\n                  x: x,\n                  y: y\n                };\n                _context4.next = 5;\n                return detectOverflow(state, detectOverflowOptions);\n              case 5:\n                overflow = _context4.sent;\n                mainAxis = getMainAxisFromPlacement(getSide(placement));\n                crossAxis = getCrossAxis(mainAxis);\n                mainAxisCoord = coords[mainAxis];\n                crossAxisCoord = coords[crossAxis];\n                if (checkMainAxis) {\n                  minSide = mainAxis === 'y' ? 'top' : 'left';\n                  maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n                  _min = mainAxisCoord + overflow[minSide];\n                  _max = mainAxisCoord - overflow[maxSide];\n                  mainAxisCoord = within(_min, mainAxisCoord, _max);\n                }\n                if (checkCrossAxis) {\n                  _minSide = crossAxis === 'y' ? 'top' : 'left';\n                  _maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n                  _min2 = crossAxisCoord + overflow[_minSide];\n                  _max2 = crossAxisCoord - overflow[_maxSide];\n                  crossAxisCoord = within(_min2, crossAxisCoord, _max2);\n                }\n                limitedCoords = limiter.fn(_extends({}, state, (_extends3 = {}, _defineProperty(_extends3, mainAxis, mainAxisCoord), _defineProperty(_extends3, crossAxis, crossAxisCoord), _extends3)));\n                return _context4.abrupt(\"return\", _extends({}, limitedCoords, {\n                  data: {\n                    x: limitedCoords.x - x,\n                    y: limitedCoords.y - y\n                  }\n                }));\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }, _callee4);\n        }))();\n      }\n    };\n  };\n  /**\n   * Built-in `limiter` that will stop `shift()` at a certain point.\n   */\n  var limitShift = function limitShift(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return {\n      options: options,\n      fn: function fn(state) {\n        var _ref6;\n        var x = state.x,\n          y = state.y,\n          placement = state.placement,\n          rects = state.rects,\n          middlewareData = state.middlewareData;\n        var _options3 = options,\n          _options3$offset = _options3.offset,\n          offset = _options3$offset === void 0 ? 0 : _options3$offset,\n          _options3$mainAxis = _options3.mainAxis,\n          checkMainAxis = _options3$mainAxis === void 0 ? true : _options3$mainAxis,\n          _options3$crossAxis = _options3.crossAxis,\n          checkCrossAxis = _options3$crossAxis === void 0 ? true : _options3$crossAxis;\n        var coords = {\n          x: x,\n          y: y\n        };\n        var mainAxis = getMainAxisFromPlacement(placement);\n        var crossAxis = getCrossAxis(mainAxis);\n        var mainAxisCoord = coords[mainAxis];\n        var crossAxisCoord = coords[crossAxis];\n        var rawOffset = typeof offset === 'function' ? offset(state) : offset;\n        var computedOffset = typeof rawOffset === 'number' ? {\n          mainAxis: rawOffset,\n          crossAxis: 0\n        } : _extends({\n          mainAxis: 0,\n          crossAxis: 0\n        }, rawOffset);\n        if (checkMainAxis) {\n          var len = mainAxis === 'y' ? 'height' : 'width';\n          var limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n          var limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n          if (mainAxisCoord < limitMin) {\n            mainAxisCoord = limitMin;\n          } else if (mainAxisCoord > limitMax) {\n            mainAxisCoord = limitMax;\n          }\n        }\n        if (checkCrossAxis) {\n          var _middlewareData$offse, _middlewareData$offse2;\n          var _len2 = mainAxis === 'y' ? 'width' : 'height';\n          var isOriginSide = ['top', 'left'].includes(getSide(placement));\n          var _limitMin = rects.reference[crossAxis] - rects.floating[_len2] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n          var _limitMax = rects.reference[crossAxis] + rects.reference[_len2] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n          if (crossAxisCoord < _limitMin) {\n            crossAxisCoord = _limitMin;\n          } else if (crossAxisCoord > _limitMax) {\n            crossAxisCoord = _limitMax;\n          }\n        }\n        return _ref6 = {}, _defineProperty(_ref6, mainAxis, mainAxisCoord), _defineProperty(_ref6, crossAxis, crossAxisCoord), _ref6;\n      }\n    };\n  };\n  function getWindow(node) {\n    var _node$ownerDocument;\n    return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n  }\n  function getComputedStyle$1(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n  function isNode(value) {\n    return value instanceof getWindow(value).Node;\n  }\n  function getNodeName(node) {\n    return isNode(node) ? (node.nodeName || '').toLowerCase() : '';\n  }\n  var uaString;\n  function getUAString() {\n    if (uaString) {\n      return uaString;\n    }\n    var uaData = navigator.userAgentData;\n    if (uaData && Array.isArray(uaData.brands)) {\n      uaString = uaData.brands.map(function (item) {\n        return item.brand + \"/\" + item.version;\n      }).join(' ');\n      return uaString;\n    }\n    return navigator.userAgent;\n  }\n  function isHTMLElement(value) {\n    return value instanceof getWindow(value).HTMLElement;\n  }\n  function isElement(value) {\n    return value instanceof getWindow(value).Element;\n  }\n  function isShadowRoot(node) {\n    // Browsers without `ShadowRoot` support.\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  }\n  function isOverflowElement(element) {\n    var _getComputedStyle$ = getComputedStyle$1(element),\n      overflow = _getComputedStyle$.overflow,\n      overflowX = _getComputedStyle$.overflowX,\n      overflowY = _getComputedStyle$.overflowY,\n      display = _getComputedStyle$.display;\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n  }\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].includes(getNodeName(element));\n  }\n  function isContainingBlock(element) {\n    // TODO: Try to use feature detection here instead.\n    var isFirefox = /firefox/i.test(getUAString());\n    var css = getComputedStyle$1(element);\n    var backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;\n\n    // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(function (value) {\n      return css.willChange.includes(value);\n    }) || ['paint', 'layout', 'strict', 'content'].some(function (value) {\n      // Add type check for old browsers.\n      var contain = css.contain;\n      return contain != null ? contain.includes(value) : false;\n    });\n  }\n\n  /**\n   * Determines whether or not `.getBoundingClientRect()` is affected by visual\n   * viewport offsets. In Safari, the `x`/`y` offsets are values relative to the\n   * visual viewport, while in other engines, they are values relative to the\n   * layout viewport.\n   */\n  function isClientRectVisualViewportBased() {\n    // TODO: Try to use feature detection here instead. Feature detection for\n    // this can fail in various ways, making the userAgent check the most\n    // reliable:\n    // • Always-visible scrollbar or not\n    // • Width of <html>\n\n    // Is Safari.\n    return /^((?!chrome|android).)*safari/i.test(getUAString());\n  }\n  function isLastTraversableNode(node) {\n    return ['html', 'body', '#document'].includes(getNodeName(node));\n  }\n  var min = Math.min;\n  var max = Math.max;\n  var round = Math.round;\n  function getCssDimensions(element) {\n    var css = getComputedStyle$1(element);\n    var width = parseFloat(css.width);\n    var height = parseFloat(css.height);\n    var hasOffset = isHTMLElement(element);\n    var offsetWidth = hasOffset ? element.offsetWidth : width;\n    var offsetHeight = hasOffset ? element.offsetHeight : height;\n    var shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n    if (shouldFallback) {\n      width = offsetWidth;\n      height = offsetHeight;\n    }\n    return {\n      width: width,\n      height: height,\n      fallback: shouldFallback\n    };\n  }\n  function unwrapElement(element) {\n    return !isElement(element) ? element.contextElement : element;\n  }\n  var FALLBACK_SCALE = {\n    x: 1,\n    y: 1\n  };\n  function getScale(element) {\n    var domElement = unwrapElement(element);\n    if (!isHTMLElement(domElement)) {\n      return FALLBACK_SCALE;\n    }\n    var rect = domElement.getBoundingClientRect();\n    var _getCssDimensions = getCssDimensions(domElement),\n      width = _getCssDimensions.width,\n      height = _getCssDimensions.height,\n      fallback = _getCssDimensions.fallback;\n    var x = (fallback ? round(rect.width) : rect.width) / width;\n    var y = (fallback ? round(rect.height) : rect.height) / height;\n\n    // 0, NaN, or Infinity should always fallback to 1.\n\n    if (!x || !Number.isFinite(x)) {\n      x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n      y = 1;\n    }\n    return {\n      x: x,\n      y: y\n    };\n  }\n  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    var _win$visualViewport, _win$visualViewport2;\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n      isFixedStrategy = false;\n    }\n    var clientRect = element.getBoundingClientRect();\n    var domElement = unwrapElement(element);\n    var scale = FALLBACK_SCALE;\n    if (includeScale) {\n      if (offsetParent) {\n        if (isElement(offsetParent)) {\n          scale = getScale(offsetParent);\n        }\n      } else {\n        scale = getScale(element);\n      }\n    }\n    var win = domElement ? getWindow(domElement) : window;\n    var addVisualOffsets = isClientRectVisualViewportBased() && isFixedStrategy;\n    var x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;\n    var y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;\n    var width = clientRect.width / scale.x;\n    var height = clientRect.height / scale.y;\n    if (domElement) {\n      var _win = getWindow(domElement);\n      var offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n      var currentIFrame = _win.frameElement;\n      while (currentIFrame && offsetParent && offsetWin !== _win) {\n        var iframeScale = getScale(currentIFrame);\n        var iframeRect = currentIFrame.getBoundingClientRect();\n        var css = getComputedStyle(currentIFrame);\n        iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n        iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n        x *= iframeScale.x;\n        y *= iframeScale.y;\n        width *= iframeScale.x;\n        height *= iframeScale.y;\n        x += iframeRect.x;\n        y += iframeRect.y;\n        currentIFrame = getWindow(currentIFrame).frameElement;\n      }\n    }\n    return rectToClientRect({\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    });\n  }\n  function getDocumentElement(node) {\n    return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n  }\n  function getNodeScroll(element) {\n    if (isElement(element)) {\n      return {\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n      };\n    }\n    return {\n      scrollLeft: element.pageXOffset,\n      scrollTop: element.pageYOffset\n    };\n  }\n  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    var rect = _ref.rect,\n      offsetParent = _ref.offsetParent,\n      strategy = _ref.strategy;\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    if (offsetParent === documentElement) {\n      return rect;\n    }\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var scale = {\n      x: 1,\n      y: 1\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        var offsetRect = getBoundingClientRect(offsetParent);\n        scale = getScale(offsetParent);\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\n        offsets.y = offsetRect.y + offsetParent.clientTop;\n      }\n    }\n    return {\n      width: rect.width * scale.x,\n      height: rect.height * scale.y,\n      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n    };\n  }\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n  }\n\n  // Gets the entire size of the scrollable document area, even extending outside\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable.\n  function getDocumentRect(element) {\n    var html = getDocumentElement(element);\n    var scroll = getNodeScroll(element);\n    var body = element.ownerDocument.body;\n    var width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    var height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    var x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -scroll.scrollTop;\n    if (getComputedStyle$1(body).direction === 'rtl') {\n      x += max(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n  function getParentNode(node) {\n    if (getNodeName(node) === 'html') {\n      return node;\n    }\n    var result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    isShadowRoot(node) && node.host ||\n    // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n  }\n  function getNearestOverflowAncestor(node) {\n    var parentNode = getParentNode(node);\n    if (isLastTraversableNode(parentNode)) {\n      // `getParentNode` will never return a `Document` due to the fallback\n      // check, so it's either the <html> or <body> element.\n      return parentNode.ownerDocument.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n      return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n  }\n  function getOverflowAncestors(node, list) {\n    var _node$ownerDocument;\n    if (list === void 0) {\n      list = [];\n    }\n    var scrollableAncestor = getNearestOverflowAncestor(node);\n    var isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n    var win = getWindow(scrollableAncestor);\n    if (isBody) {\n      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n    }\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n  }\n  function getViewportRect(element, strategy) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0;\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height;\n      var visualViewportBased = isClientRectVisualViewportBased();\n      if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n\n  // Returns the inner client rect, subtracting scrollbars if present.\n  function getInnerBoundingClientRect(element, strategy) {\n    var clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n    var top = clientRect.top + element.clientTop;\n    var left = clientRect.left + element.clientLeft;\n    var scale = isHTMLElement(element) ? getScale(element) : {\n      x: 1,\n      y: 1\n    };\n    var width = element.clientWidth * scale.x;\n    var height = element.clientHeight * scale.y;\n    var x = left * scale.x;\n    var y = top * scale.y;\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    var rect;\n    if (clippingAncestor === 'viewport') {\n      rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === 'document') {\n      rect = getDocumentRect(getDocumentElement(element));\n    } else if (isElement(clippingAncestor)) {\n      rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n      var mutableRect = _extends({}, clippingAncestor);\n      if (isClientRectVisualViewportBased()) {\n        var _win$visualViewport, _win$visualViewport2;\n        var win = getWindow(element);\n        mutableRect.x -= ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0;\n        mutableRect.y -= ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0;\n      }\n      rect = mutableRect;\n    }\n    return rectToClientRect(rect);\n  }\n\n  // A \"clipping ancestor\" is an `overflow` element with the characteristic of\n  // clipping (or hiding) child elements. This returns all clipping ancestors\n  // of the given element up the tree.\n  function getClippingElementAncestors(element, cache) {\n    var cachedResult = cache.get(element);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    var result = getOverflowAncestors(element).filter(function (el) {\n      return isElement(el) && getNodeName(el) !== 'body';\n    });\n    var currentContainingBlockComputedStyle = null;\n    var elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n    var currentNode = elementIsFixed ? getParentNode(element) : element;\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n      var computedStyle = getComputedStyle$1(currentNode);\n      var containingBlock = isContainingBlock(currentNode);\n      var shouldIgnoreCurrentNode = computedStyle.position === 'fixed';\n      if (shouldIgnoreCurrentNode) {\n        currentContainingBlockComputedStyle = null;\n      } else {\n        var shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);\n        if (shouldDropCurrentNode) {\n          // Drop non-containing blocks.\n          result = result.filter(function (ancestor) {\n            return ancestor !== currentNode;\n          });\n        } else {\n          // Record last containing block for next iteration.\n          currentContainingBlockComputedStyle = computedStyle;\n        }\n      }\n      currentNode = getParentNode(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n  }\n\n  // Gets the maximum area that the element is visible in due to any number of\n  // clipping ancestors.\n  function getClippingRect(_ref) {\n    var element = _ref.element,\n      boundary = _ref.boundary,\n      rootBoundary = _ref.rootBoundary,\n      strategy = _ref.strategy;\n    var elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    var clippingAncestors = [].concat(_toConsumableArray(elementClippingAncestors), [rootBoundary]);\n    var firstClippingAncestor = clippingAncestors[0];\n    var clippingRect = clippingAncestors.reduce(function (accRect, clippingAncestor) {\n      var rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n      width: clippingRect.right - clippingRect.left,\n      height: clippingRect.bottom - clippingRect.top,\n      x: clippingRect.left,\n      y: clippingRect.top\n    };\n  }\n  function getDimensions(element) {\n    return getCssDimensions(element);\n  }\n  function getTrueOffsetParent(element, polyfill) {\n    if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n      return null;\n    }\n    if (polyfill) {\n      return polyfill(element);\n    }\n    return element.offsetParent;\n  }\n  function getContainingBlock(element) {\n    var currentNode = getParentNode(element);\n    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n      if (isContainingBlock(currentNode)) {\n        return currentNode;\n      } else {\n        currentNode = getParentNode(currentNode);\n      }\n    }\n    return null;\n  }\n\n  // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n  function getOffsetParent(element, polyfill) {\n    var window = getWindow(element);\n    if (!isHTMLElement(element)) {\n      return window;\n    }\n    var offsetParent = getTrueOffsetParent(element, polyfill);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n      return window;\n    }\n    return offsetParent || getContainingBlock(element) || window;\n  }\n  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        var offsetRect = getBoundingClientRect(offsetParent, true);\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\n        offsets.y = offsetRect.y + offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n  var platform = {\n    getClippingRect: getClippingRect,\n    convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect,\n    isElement: isElement,\n    getDimensions: getDimensions,\n    getOffsetParent: getOffsetParent,\n    getDocumentElement: getDocumentElement,\n    getScale: getScale,\n    getElementRects: function getElementRects(_ref) {\n      var _this3 = this;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var reference, floating, strategy, getOffsetParentFn, getDimensionsFn;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              reference = _ref.reference, floating = _ref.floating, strategy = _ref.strategy;\n              getOffsetParentFn = _this3.getOffsetParent || getOffsetParent;\n              getDimensionsFn = _this3.getDimensions;\n              _context5.t0 = getRectRelativeToOffsetParent;\n              _context5.t1 = reference;\n              _context5.next = 7;\n              return getOffsetParentFn(floating);\n            case 7:\n              _context5.t2 = _context5.sent;\n              _context5.t3 = strategy;\n              _context5.t4 = (0, _context5.t0)(_context5.t1, _context5.t2, _context5.t3);\n              _context5.t5 = _extends;\n              _context5.t6 = {\n                x: 0,\n                y: 0\n              };\n              _context5.next = 14;\n              return getDimensionsFn(floating);\n            case 14:\n              _context5.t7 = _context5.sent;\n              _context5.t8 = (0, _context5.t5)(_context5.t6, _context5.t7);\n              return _context5.abrupt(\"return\", {\n                reference: _context5.t4,\n                floating: _context5.t8\n              });\n            case 17:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5);\n      }))();\n    },\n    getClientRects: function getClientRects(element) {\n      return Array.from(element.getClientRects());\n    },\n    isRTL: function isRTL(element) {\n      return getComputedStyle$1(element).direction === 'rtl';\n    }\n  };\n\n  /**\n   * Automatically updates the position of the floating element when necessary.\n   * Should only be called when the floating element is mounted on the DOM or\n   * visible on the screen.\n   * @returns cleanup function that should be invoked when the floating element is\n   * removed from the DOM or hidden from the screen.\n   * @see https://floating-ui.com/docs/autoUpdate\n   */\n  function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options4 = options,\n      _options4$ancestorScr = _options4.ancestorScroll,\n      _ancestorScroll = _options4$ancestorScr === void 0 ? true : _options4$ancestorScr,\n      _options4$ancestorRes = _options4.ancestorResize,\n      ancestorResize = _options4$ancestorRes === void 0 ? true : _options4$ancestorRes,\n      _options4$elementResi = _options4.elementResize,\n      elementResize = _options4$elementResi === void 0 ? true : _options4$elementResi,\n      _options4$animationFr = _options4.animationFrame,\n      animationFrame = _options4$animationFr === void 0 ? false : _options4$animationFr;\n    var ancestorScroll = _ancestorScroll && !animationFrame;\n    var ancestors = ancestorScroll || ancestorResize ? [].concat(_toConsumableArray(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), _toConsumableArray(getOverflowAncestors(floating))) : [];\n    ancestors.forEach(function (ancestor) {\n      ancestorScroll && ancestor.addEventListener('scroll', update, {\n        passive: true\n      });\n      ancestorResize && ancestor.addEventListener('resize', update);\n    });\n    var observer = null;\n    if (elementResize) {\n      observer = new ResizeObserver(function () {\n        update();\n      });\n      isElement(reference) && !animationFrame && observer.observe(reference);\n      if (!isElement(reference) && reference.contextElement && !animationFrame) {\n        observer.observe(reference.contextElement);\n      }\n      observer.observe(floating);\n    }\n    var frameId;\n    var prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n      frameLoop();\n    }\n    function frameLoop() {\n      var nextRefRect = getBoundingClientRect(reference);\n      if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n        update();\n      }\n      prevRefRect = nextRefRect;\n      frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return function () {\n      var _observer;\n      ancestors.forEach(function (ancestor) {\n        ancestorScroll && ancestor.removeEventListener('scroll', update);\n        ancestorResize && ancestor.removeEventListener('resize', update);\n      });\n      (_observer = observer) == null ? void 0 : _observer.disconnect();\n      observer = null;\n      if (animationFrame) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }\n\n  /**\n   * Computes the `x` and `y` coordinates that will place the floating element\n   * next to a reference element when it is given a certain CSS positioning\n   * strategy.\n   */\n  var computePosition = function computePosition(reference, floating, options) {\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    var cache = new Map();\n    var mergedOptions = _extends({\n      platform: platform\n    }, options);\n    var platformWithCache = _extends({}, mergedOptions.platform, {\n      _c: cache\n    });\n    return computePosition$1(reference, floating, _extends({}, mergedOptions, {\n      platform: platformWithCache\n    }));\n  };\n\n  /**\n   * Floating UI Options\n   *\n   * @typedef {object} FloatingUIOptions\n   */\n\n  /**\n   * Determines options for the tooltip and initializes event listeners.\n   *\n   * @param {Step} step The step instance\n   *\n   * @return {FloatingUIOptions}\n   */\n  function setupTooltip(step) {\n    if (step.cleanup) {\n      step.cleanup();\n    }\n    var attachToOptions = step._getResolvedAttachToOptions();\n    var target = attachToOptions.element;\n    var floatingUIOptions = getFloatingUIOptions(attachToOptions, step);\n    var shouldCenter = shouldCenterStep(attachToOptions);\n    if (shouldCenter) {\n      target = document.body;\n      var content = step.shepherdElementComponent.getElement();\n      content.classList.add('shepherd-centered');\n    }\n    step.cleanup = autoUpdate(target, step.el, function () {\n      // The element might have already been removed by the end of the tour.\n      if (!step.el) {\n        step.cleanup();\n        return;\n      }\n      setPosition(target, step, floatingUIOptions, shouldCenter);\n    });\n    step.target = attachToOptions.element;\n    return floatingUIOptions;\n  }\n\n  /**\n   * Merge tooltip options handling nested keys.\n   *\n   * @param tourOptions - The default tour options.\n   * @param options - Step specific options.\n   *\n   * @return {floatingUIOptions: FloatingUIOptions}\n   */\n  function mergeTooltipConfig(tourOptions, options) {\n    return {\n      floatingUIOptions: cjs(tourOptions.floatingUIOptions || {}, options.floatingUIOptions || {})\n    };\n  }\n\n  /**\n   * Cleanup function called when the step is closed/destroyed.\n   *\n   * @param {Step} step\n   */\n  function destroyTooltip(step) {\n    if (step.cleanup) {\n      step.cleanup();\n    }\n    step.cleanup = null;\n  }\n\n  /**\n   *\n   * @return {Promise<*>}\n   */\n  function setPosition(target, step, floatingUIOptions, shouldCenter) {\n    return computePosition(target, step.el, floatingUIOptions).then(floatingUIposition(step, shouldCenter))\n    // Wait before forcing focus.\n    .then(function (step) {\n      return new Promise(function (resolve) {\n        setTimeout(function () {\n          return resolve(step);\n        }, 300);\n      });\n    })\n    // Replaces focusAfterRender modifier.\n    .then(function (step) {\n      if (step && step.el) {\n        step.el.focus({\n          preventScroll: true\n        });\n      }\n    });\n  }\n\n  /**\n   *\n   * @param step\n   * @param shouldCenter\n   * @return {function({x: *, y: *, placement: *, middlewareData: *}): Promise<unknown>}\n   */\n  function floatingUIposition(step, shouldCenter) {\n    return function (_ref) {\n      var x = _ref.x,\n        y = _ref.y,\n        placement = _ref.placement,\n        middlewareData = _ref.middlewareData;\n      if (!step.el) {\n        return step;\n      }\n      if (shouldCenter) {\n        Object.assign(step.el.style, {\n          position: 'fixed',\n          left: '50%',\n          top: '50%',\n          transform: 'translate(-50%, -50%)'\n        });\n      } else {\n        Object.assign(step.el.style, {\n          position: 'absolute',\n          left: \"\".concat(x, \"px\"),\n          top: \"\".concat(y, \"px\")\n        });\n      }\n      step.el.dataset.popperPlacement = placement;\n      placeArrow(step.el, middlewareData);\n      return step;\n    };\n  }\n\n  /**\n   *\n   * @param el\n   * @param middlewareData\n   */\n  function placeArrow(el, middlewareData) {\n    var arrowEl = el.querySelector('.shepherd-arrow');\n    if (arrowEl && middlewareData.arrow) {\n      var _middlewareData$arrow = middlewareData.arrow,\n        arrowX = _middlewareData$arrow.x,\n        arrowY = _middlewareData$arrow.y;\n      Object.assign(arrowEl.style, {\n        left: arrowX != null ? \"\".concat(arrowX, \"px\") : '',\n        top: arrowY != null ? \"\".concat(arrowY, \"px\") : ''\n      });\n    }\n  }\n\n  /**\n   * Gets the `Floating UI` options from a set of base `attachTo` options\n   * @param attachToOptions\n   * @param {Step} step The step instance\n   * @return {Object}\n   * @private\n   */\n  function getFloatingUIOptions(attachToOptions, step) {\n    var options = {\n      strategy: 'absolute',\n      middleware: []\n    };\n    var arrowEl = addArrow(step);\n    var shouldCenter = shouldCenterStep(attachToOptions);\n    if (!shouldCenter) {\n      options.middleware.push(flip(),\n      // Replicate PopperJS default behavior.\n      shift({\n        limiter: limitShift(),\n        crossAxis: true\n      }));\n      if (arrowEl) {\n        options.middleware.push(arrow({\n          element: arrowEl\n        }));\n      }\n      options.placement = attachToOptions.on;\n    }\n    return cjs(step.options.floatingUIOptions || {}, options);\n  }\n\n  /**\n   * @param {Step} step\n   * @return {HTMLElement|false|null}\n   */\n  function addArrow(step) {\n    if (step.options.arrow && step.el) {\n      return step.el.querySelector('.shepherd-arrow');\n    }\n    return false;\n  }\n  function noop() {}\n  function assign(tar, src) {\n    // @ts-ignore\n    for (var k in src) tar[k] = src[k];\n    return tar;\n  }\n  function run(fn) {\n    return fn();\n  }\n  function blank_object() {\n    return Object.create(null);\n  }\n  function run_all(fns) {\n    fns.forEach(run);\n  }\n  function is_function(thing) {\n    return typeof thing === 'function';\n  }\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n  }\n  function is_empty(obj) {\n    return Object.keys(obj).length === 0;\n  }\n  function append(target, node) {\n    target.appendChild(node);\n  }\n  function insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n  function detach(node) {\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  }\n  function destroy_each(iterations, detaching) {\n    for (var i = 0; i < iterations.length; i += 1) {\n      if (iterations[i]) iterations[i].d(detaching);\n    }\n  }\n  function element(name) {\n    return document.createElement(name);\n  }\n  function svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n  function text(data) {\n    return document.createTextNode(data);\n  }\n  function space() {\n    return text(' ');\n  }\n  function empty() {\n    return text('');\n  }\n  function listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return function () {\n      return node.removeEventListener(event, handler, options);\n    };\n  }\n  function attr(node, attribute, value) {\n    if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n  }\n  function set_attributes(node, attributes) {\n    // @ts-ignore\n    var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (var key in attributes) {\n      if (attributes[key] == null) {\n        node.removeAttribute(key);\n      } else if (key === 'style') {\n        node.style.cssText = attributes[key];\n      } else if (key === '__value') {\n        node.value = node[key] = attributes[key];\n      } else if (descriptors[key] && descriptors[key].set) {\n        node[key] = attributes[key];\n      } else {\n        attr(node, key, attributes[key]);\n      }\n    }\n  }\n  function children(element) {\n    return Array.from(element.childNodes);\n  }\n  function toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n  }\n  var current_component;\n  function set_current_component(component) {\n    current_component = component;\n  }\n  function get_current_component() {\n    if (!current_component) throw new Error('Function called outside component initialization');\n    return current_component;\n  }\n  /**\n   * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n   * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n   * it can be called from an external module).\n   *\n   * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n   *\n   * https://svelte.dev/docs#run-time-svelte-onmount\n   */\n  function onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n  }\n  /**\n   * Schedules a callback to run immediately after the component has been updated.\n   *\n   * The first time the callback runs will be after the initial `onMount`\n   */\n  function afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n  }\n  var dirty_components = [];\n  var binding_callbacks = [];\n  var render_callbacks = [];\n  var flush_callbacks = [];\n  var resolved_promise = /* @__PURE__ */Promise.resolve();\n  var update_scheduled = false;\n  function schedule_update() {\n    if (!update_scheduled) {\n      update_scheduled = true;\n      resolved_promise.then(flush);\n    }\n  }\n  function add_render_callback(fn) {\n    render_callbacks.push(fn);\n  }\n  // flush() calls callbacks in this order:\n  // 1. All beforeUpdate callbacks, in order: parents before children\n  // 2. All bind:this callbacks, in reverse order: children before parents.\n  // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n  //    for afterUpdates called during the initial onMount, which are called in\n  //    reverse order: children before parents.\n  // Since callbacks might update component values, which could trigger another\n  // call to flush(), the following steps guard against this:\n  // 1. During beforeUpdate, any updated components will be added to the\n  //    dirty_components array and will cause a reentrant call to flush(). Because\n  //    the flush index is kept outside the function, the reentrant call will pick\n  //    up where the earlier call left off and go through all dirty components. The\n  //    current_component value is saved and restored so that the reentrant call will\n  //    not interfere with the \"parent\" flush() call.\n  // 2. bind:this callbacks cannot trigger new flush() calls.\n  // 3. During afterUpdate, any updated components will NOT have their afterUpdate\n  //    callback called a second time; the seen_callbacks set, outside the flush()\n  //    function, guarantees this behavior.\n  var seen_callbacks = new Set();\n  var flushidx = 0; // Do *not* move this inside the flush() function\n  function flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n      return;\n    }\n    var saved_component = current_component;\n    do {\n      // first, call beforeUpdate functions\n      // and update components\n      try {\n        while (flushidx < dirty_components.length) {\n          var component = dirty_components[flushidx];\n          flushidx++;\n          set_current_component(component);\n          update(component.$$);\n        }\n      } catch (e) {\n        // reset dirty state to not end up in a deadlocked state and then rethrow\n        dirty_components.length = 0;\n        flushidx = 0;\n        throw e;\n      }\n      set_current_component(null);\n      dirty_components.length = 0;\n      flushidx = 0;\n      while (binding_callbacks.length) binding_callbacks.pop()();\n      // then, once components are updated, call\n      // afterUpdate functions. This may cause\n      // subsequent updates...\n      for (var i = 0; i < render_callbacks.length; i += 1) {\n        var callback = render_callbacks[i];\n        if (!seen_callbacks.has(callback)) {\n          // ...so guard against infinite loops\n          seen_callbacks.add(callback);\n          callback();\n        }\n      }\n      render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n      flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n  }\n  function update($$) {\n    if ($$.fragment !== null) {\n      $$.update();\n      run_all($$.before_update);\n      var dirty = $$.dirty;\n      $$.dirty = [-1];\n      $$.fragment && $$.fragment.p($$.ctx, dirty);\n      $$.after_update.forEach(add_render_callback);\n    }\n  }\n  /**\n   * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n   */\n  function flush_render_callbacks(fns) {\n    var filtered = [];\n    var targets = [];\n    render_callbacks.forEach(function (c) {\n      return fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c);\n    });\n    targets.forEach(function (c) {\n      return c();\n    });\n    render_callbacks = filtered;\n  }\n  var outroing = new Set();\n  var outros;\n  function group_outros() {\n    outros = {\n      r: 0,\n      c: [],\n      p: outros // parent group\n    };\n  }\n\n  function check_outros() {\n    if (!outros.r) {\n      run_all(outros.c);\n    }\n    outros = outros.p;\n  }\n  function transition_in(block, local) {\n    if (block && block.i) {\n      outroing.delete(block);\n      block.i(local);\n    }\n  }\n  function transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n      if (outroing.has(block)) return;\n      outroing.add(block);\n      outros.c.push(function () {\n        outroing.delete(block);\n        if (callback) {\n          if (detach) block.d(1);\n          callback();\n        }\n      });\n      block.o(local);\n    } else if (callback) {\n      callback();\n    }\n  }\n  function get_spread_update(levels, updates) {\n    var update = {};\n    var to_null_out = {};\n    var accounted_for = {\n      $$scope: 1\n    };\n    var i = levels.length;\n    while (i--) {\n      var o = levels[i];\n      var n = updates[i];\n      if (n) {\n        for (var key in o) {\n          if (!(key in n)) to_null_out[key] = 1;\n        }\n        for (var _key2 in n) {\n          if (!accounted_for[_key2]) {\n            update[_key2] = n[_key2];\n            accounted_for[_key2] = 1;\n          }\n        }\n        levels[i] = n;\n      } else {\n        for (var _key3 in o) {\n          accounted_for[_key3] = 1;\n        }\n      }\n    }\n    for (var _key4 in to_null_out) {\n      if (!(_key4 in update)) update[_key4] = undefined;\n    }\n    return update;\n  }\n  function create_component(block) {\n    block && block.c();\n  }\n  function mount_component(component, target, anchor, customElement) {\n    var _component$$$ = component.$$,\n      fragment = _component$$$.fragment,\n      after_update = _component$$$.after_update;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n      // onMount happens before the initial afterUpdate\n      add_render_callback(function () {\n        var new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n        // if the component was destroyed immediately\n        // it will update the `$$.on_destroy` reference to `null`.\n        // the destructured on_destroy may still reference to the old array\n        if (component.$$.on_destroy) {\n          var _component$$$$on_dest;\n          (_component$$$$on_dest = component.$$.on_destroy).push.apply(_component$$$$on_dest, _toConsumableArray(new_on_destroy));\n        } else {\n          // Edge case - component was destroyed immediately,\n          // most likely as a result of a binding initialising\n          run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n      });\n    }\n    after_update.forEach(add_render_callback);\n  }\n  function destroy_component(component, detaching) {\n    var $$ = component.$$;\n    if ($$.fragment !== null) {\n      flush_render_callbacks($$.after_update);\n      run_all($$.on_destroy);\n      $$.fragment && $$.fragment.d(detaching);\n      // TODO null out other refs, including component.$$ (but need to\n      // preserve final state?)\n      $$.on_destroy = $$.fragment = null;\n      $$.ctx = [];\n    }\n  }\n  function make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n      dirty_components.push(component);\n      schedule_update();\n      component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n  }\n  function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty) {\n    if (dirty === void 0) {\n      dirty = [-1];\n    }\n    var parent_component = current_component;\n    set_current_component(component);\n    var $$ = component.$$ = {\n      fragment: null,\n      ctx: [],\n      // state\n      props: props,\n      update: noop,\n      not_equal: not_equal,\n      bound: blank_object(),\n      // lifecycle\n      on_mount: [],\n      on_destroy: [],\n      on_disconnect: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n      // everything else\n      callbacks: blank_object(),\n      dirty: dirty,\n      skip_bound: false,\n      root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    var ready = false;\n    $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {\n      var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n      return ret;\n    }) : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n      if (options.hydrate) {\n        var nodes = children(options.target);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.l(nodes);\n        nodes.forEach(detach);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.c();\n      }\n      if (options.intro) transition_in(component.$$.fragment);\n      mount_component(component, options.target, options.anchor, options.customElement);\n      flush();\n    }\n    set_current_component(parent_component);\n  }\n  /**\n   * Base class for Svelte components. Used when dev=false.\n   */\n  var SvelteComponent = /*#__PURE__*/function () {\n    function SvelteComponent() {\n      _classCallCheck(this, SvelteComponent);\n    }\n    _createClass(SvelteComponent, [{\n      key: \"$destroy\",\n      value: function $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n      }\n    }, {\n      key: \"$on\",\n      value: function $on(type, callback) {\n        if (!is_function(callback)) {\n          return noop;\n        }\n        var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n        callbacks.push(callback);\n        return function () {\n          var index = callbacks.indexOf(callback);\n          if (index !== -1) callbacks.splice(index, 1);\n        };\n      }\n    }, {\n      key: \"$set\",\n      value: function $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n          this.$$.skip_bound = true;\n          this.$$set($$props);\n          this.$$.skip_bound = false;\n        }\n      }\n    }]);\n    return SvelteComponent;\n  }();\n  /* src/js/components/shepherd-button.svelte generated by Svelte v3.58.0 */\n  function create_fragment$8(ctx) {\n    var button;\n    var button_aria_label_value;\n    var button_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        attr(button, \"aria-label\", button_aria_label_value = /*label*/ctx[3] ? /*label*/ctx[3] : null);\n        attr(button, \"class\", button_class_value = \"\".concat( /*classes*/ctx[1] || '', \" shepherd-button \").concat( /*secondary*/ctx[4] ? 'shepherd-button-secondary' : ''));\n        button.disabled = /*disabled*/ctx[2];\n        attr(button, \"tabindex\", \"0\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        button.innerHTML = /*text*/ctx[5];\n        if (!mounted) {\n          dispose = listen(button, \"click\", function () {\n            if (is_function( /*action*/ctx[0])) /*action*/ctx[0].apply(this, arguments);\n          });\n          mounted = true;\n        }\n      },\n      p: function p(new_ctx, _ref) {\n        var _ref7 = _slicedToArray(_ref, 1),\n          dirty = _ref7[0];\n        ctx = new_ctx;\n        if (dirty & /*text*/32) button.innerHTML = /*text*/ctx[5];\n        if (dirty & /*label*/8 && button_aria_label_value !== (button_aria_label_value = /*label*/ctx[3] ? /*label*/ctx[3] : null)) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n        if (dirty & /*classes, secondary*/18 && button_class_value !== (button_class_value = \"\".concat( /*classes*/ctx[1] || '', \" shepherd-button \").concat( /*secondary*/ctx[4] ? 'shepherd-button-secondary' : ''))) {\n          attr(button, \"class\", button_class_value);\n        }\n        if (dirty & /*disabled*/4) {\n          button.disabled = /*disabled*/ctx[2];\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$8($$self, $$props, $$invalidate) {\n    var config = $$props.config,\n      step = $$props.step;\n    var action, classes, disabled, label, secondary, text;\n    function getConfigOption(option) {\n      if (isFunction(option)) {\n        return option = option.call(step);\n      }\n      return option;\n    }\n    $$self.$$set = function ($$props) {\n      if ('config' in $$props) $$invalidate(6, config = $$props.config);\n      if ('step' in $$props) $$invalidate(7, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*config, step*/192) {\n        {\n          $$invalidate(0, action = config.action ? config.action.bind(step.tour) : null);\n          $$invalidate(1, classes = config.classes);\n          $$invalidate(2, disabled = config.disabled ? getConfigOption(config.disabled) : false);\n          $$invalidate(3, label = config.label ? getConfigOption(config.label) : null);\n          $$invalidate(4, secondary = config.secondary);\n          $$invalidate(5, text = config.text ? getConfigOption(config.text) : null);\n        }\n      }\n    };\n    return [action, classes, disabled, label, secondary, text, config, step];\n  }\n  var Shepherd_button = /*#__PURE__*/function (_SvelteComponent) {\n    _inherits(Shepherd_button, _SvelteComponent);\n    var _super = _createSuper(Shepherd_button);\n    function Shepherd_button(options) {\n      var _this4;\n      _classCallCheck(this, Shepherd_button);\n      _this4 = _super.call(this);\n      init(_assertThisInitialized(_this4), options, instance$8, create_fragment$8, safe_not_equal, {\n        config: 6,\n        step: 7\n      });\n      return _this4;\n    }\n    return _createClass(Shepherd_button);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-footer.svelte generated by Svelte v3.58.0 */\n  function get_each_context(ctx, list, i) {\n    var child_ctx = ctx.slice();\n    child_ctx[2] = list[i];\n    return child_ctx;\n  }\n\n  // (24:4) {#if buttons}\n  function create_if_block$3(ctx) {\n    var each_1_anchor;\n    var current;\n    var each_value = /*buttons*/ctx[1];\n    var each_blocks = [];\n    for (var i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    }\n    var out = function out(i) {\n      return transition_out(each_blocks[i], 1, 1, function () {\n        each_blocks[i] = null;\n      });\n    };\n    return {\n      c: function c() {\n        for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {\n          each_blocks[_i2].c();\n        }\n        each_1_anchor = empty();\n      },\n      m: function m(target, anchor) {\n        for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {\n          if (each_blocks[_i3]) {\n            each_blocks[_i3].m(target, anchor);\n          }\n        }\n        insert(target, each_1_anchor, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        if (dirty & /*buttons, step*/3) {\n          each_value = /*buttons*/ctx[1];\n          var _i4;\n          for (_i4 = 0; _i4 < each_value.length; _i4 += 1) {\n            var child_ctx = get_each_context(ctx, each_value, _i4);\n            if (each_blocks[_i4]) {\n              each_blocks[_i4].p(child_ctx, dirty);\n              transition_in(each_blocks[_i4], 1);\n            } else {\n              each_blocks[_i4] = create_each_block(child_ctx);\n              each_blocks[_i4].c();\n              transition_in(each_blocks[_i4], 1);\n              each_blocks[_i4].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n          group_outros();\n          for (_i4 = each_value.length; _i4 < each_blocks.length; _i4 += 1) {\n            out(_i4);\n          }\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        for (var _i5 = 0; _i5 < each_value.length; _i5 += 1) {\n          transition_in(each_blocks[_i5]);\n        }\n        current = true;\n      },\n      o: function o(local) {\n        each_blocks = each_blocks.filter(Boolean);\n        for (var _i6 = 0; _i6 < each_blocks.length; _i6 += 1) {\n          transition_out(each_blocks[_i6]);\n        }\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_each(each_blocks, detaching);\n        if (detaching) detach(each_1_anchor);\n      }\n    };\n  }\n\n  // (25:8) {#each buttons as config}\n  function create_each_block(ctx) {\n    var shepherdbutton;\n    var current;\n    shepherdbutton = new Shepherd_button({\n      props: {\n        config: /*config*/ctx[2],\n        step: /*step*/ctx[0]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdbutton.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdbutton, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdbutton_changes = {};\n        if (dirty & /*buttons*/2) shepherdbutton_changes.config = /*config*/ctx[2];\n        if (dirty & /*step*/1) shepherdbutton_changes.step = /*step*/ctx[0];\n        shepherdbutton.$set(shepherdbutton_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdbutton.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdbutton.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdbutton, detaching);\n      }\n    };\n  }\n  function create_fragment$7(ctx) {\n    var footer;\n    var current;\n    var if_block = /*buttons*/ctx[1] && create_if_block$3(ctx);\n    return {\n      c: function c() {\n        footer = element(\"footer\");\n        if (if_block) if_block.c();\n        attr(footer, \"class\", \"shepherd-footer\");\n      },\n      m: function m(target, anchor) {\n        insert(target, footer, anchor);\n        if (if_block) if_block.m(footer, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref8 = _slicedToArray(_ref, 1),\n          dirty = _ref8[0];\n        if ( /*buttons*/ctx[1]) {\n          if (if_block) {\n            if_block.p(ctx, dirty);\n            if (dirty & /*buttons*/2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block$3(ctx);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(footer, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, function () {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(footer);\n        if (if_block) if_block.d();\n      }\n    };\n  }\n  function instance$7($$self, $$props, $$invalidate) {\n    var buttons;\n    var step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('step' in $$props) $$invalidate(0, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/1) {\n        $$invalidate(1, buttons = step.options.buttons);\n      }\n    };\n    return [step, buttons];\n  }\n  var Shepherd_footer = /*#__PURE__*/function (_SvelteComponent2) {\n    _inherits(Shepherd_footer, _SvelteComponent2);\n    var _super2 = _createSuper(Shepherd_footer);\n    function Shepherd_footer(options) {\n      var _this5;\n      _classCallCheck(this, Shepherd_footer);\n      _this5 = _super2.call(this);\n      init(_assertThisInitialized(_this5), options, instance$7, create_fragment$7, safe_not_equal, {\n        step: 0\n      });\n      return _this5;\n    }\n    return _createClass(Shepherd_footer);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-cancel-icon.svelte generated by Svelte v3.58.0 */\n  function create_fragment$6(ctx) {\n    var button;\n    var span;\n    var button_aria_label_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        span = element(\"span\");\n        span.textContent = \"×\";\n        attr(span, \"aria-hidden\", \"true\");\n        attr(button, \"aria-label\", button_aria_label_value = /*cancelIcon*/ctx[0].label ? /*cancelIcon*/ctx[0].label : 'Close Tour');\n        attr(button, \"class\", \"shepherd-cancel-icon\");\n        attr(button, \"type\", \"button\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        append(button, span);\n        if (!mounted) {\n          dispose = listen(button, \"click\", /*handleCancelClick*/ctx[1]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref9 = _slicedToArray(_ref, 1),\n          dirty = _ref9[0];\n        if (dirty & /*cancelIcon*/1 && button_aria_label_value !== (button_aria_label_value = /*cancelIcon*/ctx[0].label ? /*cancelIcon*/ctx[0].label : 'Close Tour')) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$6($$self, $$props, $$invalidate) {\n    var cancelIcon = $$props.cancelIcon,\n      step = $$props.step;\n\n    /**\n    * Add a click listener to the cancel link that cancels the tour\n    */\n    var handleCancelClick = function handleCancelClick(e) {\n      e.preventDefault();\n      step.cancel();\n    };\n    $$self.$$set = function ($$props) {\n      if ('cancelIcon' in $$props) $$invalidate(0, cancelIcon = $$props.cancelIcon);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [cancelIcon, handleCancelClick, step];\n  }\n  var Shepherd_cancel_icon = /*#__PURE__*/function (_SvelteComponent3) {\n    _inherits(Shepherd_cancel_icon, _SvelteComponent3);\n    var _super3 = _createSuper(Shepherd_cancel_icon);\n    function Shepherd_cancel_icon(options) {\n      var _this6;\n      _classCallCheck(this, Shepherd_cancel_icon);\n      _this6 = _super3.call(this);\n      init(_assertThisInitialized(_this6), options, instance$6, create_fragment$6, safe_not_equal, {\n        cancelIcon: 0,\n        step: 2\n      });\n      return _this6;\n    }\n    return _createClass(Shepherd_cancel_icon);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-title.svelte generated by Svelte v3.58.0 */\n  function create_fragment$5(ctx) {\n    var h3;\n    return {\n      c: function c() {\n        h3 = element(\"h3\");\n        attr(h3, \"id\", /*labelId*/ctx[1]);\n        attr(h3, \"class\", \"shepherd-title\");\n      },\n      m: function m(target, anchor) {\n        insert(target, h3, anchor);\n        /*h3_binding*/\n        ctx[3](h3);\n      },\n      p: function p(ctx, _ref) {\n        var _ref10 = _slicedToArray(_ref, 1),\n          dirty = _ref10[0];\n        if (dirty & /*labelId*/2) {\n          attr(h3, \"id\", /*labelId*/ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(h3);\n        /*h3_binding*/\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$5($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      element = $$props.element,\n      title = $$props.title;\n    afterUpdate(function () {\n      if (isFunction(title)) {\n        $$invalidate(2, title = title());\n      }\n      $$invalidate(0, element.innerHTML = title, element);\n    });\n    function h3_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('title' in $$props) $$invalidate(2, title = $$props.title);\n    };\n    return [element, labelId, title, h3_binding];\n  }\n  var Shepherd_title = /*#__PURE__*/function (_SvelteComponent4) {\n    _inherits(Shepherd_title, _SvelteComponent4);\n    var _super4 = _createSuper(Shepherd_title);\n    function Shepherd_title(options) {\n      var _this7;\n      _classCallCheck(this, Shepherd_title);\n      _this7 = _super4.call(this);\n      init(_assertThisInitialized(_this7), options, instance$5, create_fragment$5, safe_not_equal, {\n        labelId: 1,\n        element: 0,\n        title: 2\n      });\n      return _this7;\n    }\n    return _createClass(Shepherd_title);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-header.svelte generated by Svelte v3.58.0 */\n  function create_if_block_1$1(ctx) {\n    var shepherdtitle;\n    var current;\n    shepherdtitle = new Shepherd_title({\n      props: {\n        labelId: /*labelId*/ctx[0],\n        title: /*title*/ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtitle.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtitle, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtitle_changes = {};\n        if (dirty & /*labelId*/1) shepherdtitle_changes.labelId = /*labelId*/ctx[0];\n        if (dirty & /*title*/4) shepherdtitle_changes.title = /*title*/ctx[2];\n        shepherdtitle.$set(shepherdtitle_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtitle.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtitle.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtitle, detaching);\n      }\n    };\n  }\n\n  // (39:4) {#if cancelIcon && cancelIcon.enabled}\n  function create_if_block$2(ctx) {\n    var shepherdcancelicon;\n    var current;\n    shepherdcancelicon = new Shepherd_cancel_icon({\n      props: {\n        cancelIcon: /*cancelIcon*/ctx[3],\n        step: /*step*/ctx[1]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdcancelicon.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdcancelicon, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdcancelicon_changes = {};\n        if (dirty & /*cancelIcon*/8) shepherdcancelicon_changes.cancelIcon = /*cancelIcon*/ctx[3];\n        if (dirty & /*step*/2) shepherdcancelicon_changes.step = /*step*/ctx[1];\n        shepherdcancelicon.$set(shepherdcancelicon_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcancelicon.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcancelicon.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdcancelicon, detaching);\n      }\n    };\n  }\n  function create_fragment$4(ctx) {\n    var header;\n    var t;\n    var current;\n    var if_block0 = /*title*/ctx[2] && create_if_block_1$1(ctx);\n    var if_block1 = /*cancelIcon*/ctx[3] && /*cancelIcon*/ctx[3].enabled && create_if_block$2(ctx);\n    return {\n      c: function c() {\n        header = element(\"header\");\n        if (if_block0) if_block0.c();\n        t = space();\n        if (if_block1) if_block1.c();\n        attr(header, \"class\", \"shepherd-header\");\n      },\n      m: function m(target, anchor) {\n        insert(target, header, anchor);\n        if (if_block0) if_block0.m(header, null);\n        append(header, t);\n        if (if_block1) if_block1.m(header, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref11 = _slicedToArray(_ref, 1),\n          dirty = _ref11[0];\n        if ( /*title*/ctx[2]) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*title*/4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_1$1(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(header, t);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if ( /*cancelIcon*/ctx[3] && /*cancelIcon*/ctx[3].enabled) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*cancelIcon*/8) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block$2(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(header, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(header);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n  }\n  function instance$4($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      step = $$props.step;\n    var title, cancelIcon;\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(0, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(1, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/2) {\n        {\n          $$invalidate(2, title = step.options.title);\n          $$invalidate(3, cancelIcon = step.options.cancelIcon);\n        }\n      }\n    };\n    return [labelId, step, title, cancelIcon];\n  }\n  var Shepherd_header = /*#__PURE__*/function (_SvelteComponent5) {\n    _inherits(Shepherd_header, _SvelteComponent5);\n    var _super5 = _createSuper(Shepherd_header);\n    function Shepherd_header(options) {\n      var _this8;\n      _classCallCheck(this, Shepherd_header);\n      _this8 = _super5.call(this);\n      init(_assertThisInitialized(_this8), options, instance$4, create_fragment$4, safe_not_equal, {\n        labelId: 0,\n        step: 1\n      });\n      return _this8;\n    }\n    return _createClass(Shepherd_header);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-text.svelte generated by Svelte v3.58.0 */\n  function create_fragment$3(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-text\");\n        attr(div, \"id\", /*descriptionId*/ctx[1]);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        /*div_binding*/\n        ctx[3](div);\n      },\n      p: function p(ctx, _ref) {\n        var _ref12 = _slicedToArray(_ref, 1),\n          dirty = _ref12[0];\n        if (dirty & /*descriptionId*/2) {\n          attr(div, \"id\", /*descriptionId*/ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        /*div_binding*/\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$3($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      element = $$props.element,\n      step = $$props.step;\n    afterUpdate(function () {\n      var text = step.options.text;\n      if (isFunction(text)) {\n        text = text.call(step);\n      }\n      if (isHTMLElement$1(text)) {\n        element.appendChild(text);\n      } else {\n        $$invalidate(0, element.innerHTML = text, element);\n      }\n    });\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(1, descriptionId = $$props.descriptionId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [element, descriptionId, step, div_binding];\n  }\n  var Shepherd_text = /*#__PURE__*/function (_SvelteComponent6) {\n    _inherits(Shepherd_text, _SvelteComponent6);\n    var _super6 = _createSuper(Shepherd_text);\n    function Shepherd_text(options) {\n      var _this9;\n      _classCallCheck(this, Shepherd_text);\n      _this9 = _super6.call(this);\n      init(_assertThisInitialized(_this9), options, instance$3, create_fragment$3, safe_not_equal, {\n        descriptionId: 1,\n        element: 0,\n        step: 2\n      });\n      return _this9;\n    }\n    return _createClass(Shepherd_text);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-content.svelte generated by Svelte v3.58.0 */\n  function create_if_block_2(ctx) {\n    var shepherdheader;\n    var current;\n    shepherdheader = new Shepherd_header({\n      props: {\n        labelId: /*labelId*/ctx[1],\n        step: /*step*/ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdheader.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdheader, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdheader_changes = {};\n        if (dirty & /*labelId*/2) shepherdheader_changes.labelId = /*labelId*/ctx[1];\n        if (dirty & /*step*/4) shepherdheader_changes.step = /*step*/ctx[2];\n        shepherdheader.$set(shepherdheader_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdheader.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdheader.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdheader, detaching);\n      }\n    };\n  }\n\n  // (28:2) {#if !isUndefined(step.options.text)}\n  function create_if_block_1(ctx) {\n    var shepherdtext;\n    var current;\n    shepherdtext = new Shepherd_text({\n      props: {\n        descriptionId: /*descriptionId*/ctx[0],\n        step: /*step*/ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtext.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtext, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtext_changes = {};\n        if (dirty & /*descriptionId*/1) shepherdtext_changes.descriptionId = /*descriptionId*/ctx[0];\n        if (dirty & /*step*/4) shepherdtext_changes.step = /*step*/ctx[2];\n        shepherdtext.$set(shepherdtext_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtext.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtext.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtext, detaching);\n      }\n    };\n  }\n\n  // (35:2) {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n  function create_if_block$1(ctx) {\n    var shepherdfooter;\n    var current;\n    shepherdfooter = new Shepherd_footer({\n      props: {\n        step: /*step*/ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdfooter.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdfooter, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdfooter_changes = {};\n        if (dirty & /*step*/4) shepherdfooter_changes.step = /*step*/ctx[2];\n        shepherdfooter.$set(shepherdfooter_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdfooter.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdfooter.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdfooter, detaching);\n      }\n    };\n  }\n  function create_fragment$2(ctx) {\n    var div;\n    var show_if_2 = !isUndefined( /*step*/ctx[2].options.title) || /*step*/ctx[2].options.cancelIcon && /*step*/ctx[2].options.cancelIcon.enabled;\n    var t0;\n    var show_if_1 = !isUndefined( /*step*/ctx[2].options.text);\n    var t1;\n    var show_if = Array.isArray( /*step*/ctx[2].options.buttons) && /*step*/ctx[2].options.buttons.length;\n    var current;\n    var if_block0 = show_if_2 && create_if_block_2(ctx);\n    var if_block1 = show_if_1 && create_if_block_1(ctx);\n    var if_block2 = show_if && create_if_block$1(ctx);\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        if (if_block1) if_block1.c();\n        t1 = space();\n        if (if_block2) if_block2.c();\n        attr(div, \"class\", \"shepherd-content\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block0) if_block0.m(div, null);\n        append(div, t0);\n        if (if_block1) if_block1.m(div, null);\n        append(div, t1);\n        if (if_block2) if_block2.m(div, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref13 = _slicedToArray(_ref, 1),\n          dirty = _ref13[0];\n        if (dirty & /*step*/4) show_if_2 = !isUndefined( /*step*/ctx[2].options.title) || /*step*/ctx[2].options.cancelIcon && /*step*/ctx[2].options.cancelIcon.enabled;\n        if (show_if_2) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*step*/4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_2(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(div, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/4) show_if_1 = !isUndefined( /*step*/ctx[2].options.text);\n        if (show_if_1) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*step*/4) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_1(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(div, t1);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/4) show_if = Array.isArray( /*step*/ctx[2].options.buttons) && /*step*/ctx[2].options.buttons.length;\n        if (show_if) {\n          if (if_block2) {\n            if_block2.p(ctx, dirty);\n            if (dirty & /*step*/4) {\n              transition_in(if_block2, 1);\n            }\n          } else {\n            if_block2 = create_if_block$1(ctx);\n            if_block2.c();\n            transition_in(if_block2, 1);\n            if_block2.m(div, null);\n          }\n        } else if (if_block2) {\n          group_outros();\n          transition_out(if_block2, 1, 1, function () {\n            if_block2 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        transition_in(if_block2);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        transition_out(if_block2);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        if (if_block2) if_block2.d();\n      }\n    };\n  }\n  function instance$2($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      labelId = $$props.labelId,\n      step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(0, descriptionId = $$props.descriptionId);\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [descriptionId, labelId, step];\n  }\n  var Shepherd_content = /*#__PURE__*/function (_SvelteComponent7) {\n    _inherits(Shepherd_content, _SvelteComponent7);\n    var _super7 = _createSuper(Shepherd_content);\n    function Shepherd_content(options) {\n      var _this10;\n      _classCallCheck(this, Shepherd_content);\n      _this10 = _super7.call(this);\n      init(_assertThisInitialized(_this10), options, instance$2, create_fragment$2, safe_not_equal, {\n        descriptionId: 0,\n        labelId: 1,\n        step: 2\n      });\n      return _this10;\n    }\n    return _createClass(Shepherd_content);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-element.svelte generated by Svelte v3.58.0 */\n  function create_if_block(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-arrow\");\n        attr(div, \"data-popper-arrow\", \"\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n      }\n    };\n  }\n  function create_fragment$1(ctx) {\n    var div;\n    var t;\n    var shepherdcontent;\n    var div_aria_describedby_value;\n    var div_aria_labelledby_value;\n    var current;\n    var mounted;\n    var dispose;\n    var if_block = /*step*/ctx[4].options.arrow && /*step*/ctx[4].options.attachTo && /*step*/ctx[4].options.attachTo.element && /*step*/ctx[4].options.attachTo.on && create_if_block();\n    shepherdcontent = new Shepherd_content({\n      props: {\n        descriptionId: /*descriptionId*/ctx[2],\n        labelId: /*labelId*/ctx[3],\n        step: /*step*/ctx[4]\n      }\n    });\n    var div_levels = [{\n      \"aria-describedby\": div_aria_describedby_value = !isUndefined( /*step*/ctx[4].options.text) ? /*descriptionId*/ctx[2] : null\n    }, {\n      \"aria-labelledby\": div_aria_labelledby_value = /*step*/ctx[4].options.title ? /*labelId*/ctx[3] : null\n    }, /*dataStepId*/ctx[1], {\n      role: \"dialog\"\n    }, {\n      tabindex: \"0\"\n    }];\n    var div_data = {};\n    for (var i = 0; i < div_levels.length; i += 1) {\n      div_data = assign(div_data, div_levels[i]);\n    }\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block) if_block.c();\n        t = space();\n        create_component(shepherdcontent.$$.fragment);\n        set_attributes(div, div_data);\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block) if_block.m(div, null);\n        append(div, t);\n        mount_component(shepherdcontent, div, null);\n        /*div_binding*/\n        ctx[13](div);\n        current = true;\n        if (!mounted) {\n          dispose = listen(div, \"keydown\", /*handleKeyDown*/ctx[7]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref14 = _slicedToArray(_ref, 1),\n          dirty = _ref14[0];\n        if ( /*step*/ctx[4].options.arrow && /*step*/ctx[4].options.attachTo && /*step*/ctx[4].options.attachTo.element && /*step*/ctx[4].options.attachTo.on) {\n          if (if_block) ;else {\n            if_block = create_if_block();\n            if_block.c();\n            if_block.m(div, t);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n        var shepherdcontent_changes = {};\n        if (dirty & /*descriptionId*/4) shepherdcontent_changes.descriptionId = /*descriptionId*/ctx[2];\n        if (dirty & /*labelId*/8) shepherdcontent_changes.labelId = /*labelId*/ctx[3];\n        if (dirty & /*step*/16) shepherdcontent_changes.step = /*step*/ctx[4];\n        shepherdcontent.$set(shepherdcontent_changes);\n        set_attributes(div, div_data = get_spread_update(div_levels, [(!current || dirty & /*step, descriptionId*/20 && div_aria_describedby_value !== (div_aria_describedby_value = !isUndefined( /*step*/ctx[4].options.text) ? /*descriptionId*/ctx[2] : null)) && {\n          \"aria-describedby\": div_aria_describedby_value\n        }, (!current || dirty & /*step, labelId*/24 && div_aria_labelledby_value !== (div_aria_labelledby_value = /*step*/ctx[4].options.title ? /*labelId*/ctx[3] : null)) && {\n          \"aria-labelledby\": div_aria_labelledby_value\n        }, dirty & /*dataStepId*/2 && /*dataStepId*/ctx[1], {\n          role: \"dialog\"\n        }, {\n          tabindex: \"0\"\n        }]));\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcontent.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcontent.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block) if_block.d();\n        destroy_component(shepherdcontent);\n        /*div_binding*/\n        ctx[13](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  var KEY_TAB = 9;\n  var KEY_ESC = 27;\n  var LEFT_ARROW = 37;\n  var RIGHT_ARROW = 39;\n  function getClassesArray(classes) {\n    return classes.split(' ').filter(function (className) {\n      return !!className.length;\n    });\n  }\n  function instance$1($$self, $$props, $$invalidate) {\n    var classPrefix = $$props.classPrefix,\n      element = $$props.element,\n      descriptionId = $$props.descriptionId,\n      firstFocusableElement = $$props.firstFocusableElement,\n      focusableElements = $$props.focusableElements,\n      labelId = $$props.labelId,\n      lastFocusableElement = $$props.lastFocusableElement,\n      step = $$props.step,\n      dataStepId = $$props.dataStepId;\n    var hasCancelIcon, hasTitle, classes;\n    var getElement = function getElement() {\n      return element;\n    };\n    onMount(function () {\n      // Get all elements that are focusable\n      $$invalidate(1, dataStepId = _defineProperty({}, \"data-\".concat(classPrefix, \"shepherd-step-id\"), step.id));\n      $$invalidate(9, focusableElements = element.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]'));\n      $$invalidate(8, firstFocusableElement = focusableElements[0]);\n      $$invalidate(10, lastFocusableElement = focusableElements[focusableElements.length - 1]);\n    });\n    afterUpdate(function () {\n      if (classes !== step.options.classes) {\n        updateDynamicClasses();\n      }\n    });\n    function updateDynamicClasses() {\n      removeClasses(classes);\n      classes = step.options.classes;\n      addClasses(classes);\n    }\n    function removeClasses(classes) {\n      if (isString(classes)) {\n        var oldClasses = getClassesArray(classes);\n        if (oldClasses.length) {\n          var _element$classList;\n          (_element$classList = element.classList).remove.apply(_element$classList, _toConsumableArray(oldClasses));\n        }\n      }\n    }\n    function addClasses(classes) {\n      if (isString(classes)) {\n        var newClasses = getClassesArray(classes);\n        if (newClasses.length) {\n          var _element$classList2;\n          (_element$classList2 = element.classList).add.apply(_element$classList2, _toConsumableArray(newClasses));\n        }\n      }\n    }\n\n    /**\n    * Setup keydown events to allow closing the modal with ESC\n    *\n    * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n    *\n    * @private\n    */\n    var handleKeyDown = function handleKeyDown(e) {\n      var _step = step,\n        tour = _step.tour;\n      switch (e.keyCode) {\n        case KEY_TAB:\n          if (focusableElements.length === 0) {\n            e.preventDefault();\n            break;\n          }\n          // Backward tab\n          if (e.shiftKey) {\n            if (document.activeElement === firstFocusableElement || document.activeElement.classList.contains('shepherd-element')) {\n              e.preventDefault();\n              lastFocusableElement.focus();\n            }\n          } else {\n            if (document.activeElement === lastFocusableElement) {\n              e.preventDefault();\n              firstFocusableElement.focus();\n            }\n          }\n          break;\n        case KEY_ESC:\n          if (tour.options.exitOnEsc) {\n            step.cancel();\n          }\n          break;\n        case LEFT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.back();\n          }\n          break;\n        case RIGHT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.next();\n          }\n          break;\n      }\n    };\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('classPrefix' in $$props) $$invalidate(11, classPrefix = $$props.classPrefix);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('descriptionId' in $$props) $$invalidate(2, descriptionId = $$props.descriptionId);\n      if ('firstFocusableElement' in $$props) $$invalidate(8, firstFocusableElement = $$props.firstFocusableElement);\n      if ('focusableElements' in $$props) $$invalidate(9, focusableElements = $$props.focusableElements);\n      if ('labelId' in $$props) $$invalidate(3, labelId = $$props.labelId);\n      if ('lastFocusableElement' in $$props) $$invalidate(10, lastFocusableElement = $$props.lastFocusableElement);\n      if ('step' in $$props) $$invalidate(4, step = $$props.step);\n      if ('dataStepId' in $$props) $$invalidate(1, dataStepId = $$props.dataStepId);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/16) {\n        {\n          $$invalidate(5, hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled);\n          $$invalidate(6, hasTitle = step.options && step.options.title);\n        }\n      }\n    };\n    return [element, dataStepId, descriptionId, labelId, step, hasCancelIcon, hasTitle, handleKeyDown, firstFocusableElement, focusableElements, lastFocusableElement, classPrefix, getElement, div_binding];\n  }\n  var Shepherd_element = /*#__PURE__*/function (_SvelteComponent8) {\n    _inherits(Shepherd_element, _SvelteComponent8);\n    var _super8 = _createSuper(Shepherd_element);\n    function Shepherd_element(options) {\n      var _this11;\n      _classCallCheck(this, Shepherd_element);\n      _this11 = _super8.call(this);\n      init(_assertThisInitialized(_this11), options, instance$1, create_fragment$1, safe_not_equal, {\n        classPrefix: 11,\n        element: 0,\n        descriptionId: 2,\n        firstFocusableElement: 8,\n        focusableElements: 9,\n        labelId: 3,\n        lastFocusableElement: 10,\n        step: 4,\n        dataStepId: 1,\n        getElement: 12\n      });\n      return _this11;\n    }\n    _createClass(Shepherd_element, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[12];\n      }\n    }]);\n    return Shepherd_element;\n  }(SvelteComponent);\n  /**\n   * A class representing steps to be added to a tour.\n   * @extends {Evented}\n   */\n  var Step = /*#__PURE__*/function (_Evented) {\n    _inherits(Step, _Evented);\n    var _super9 = _createSuper(Step);\n    /**\n     * Create a step\n     * @param {Tour} tour The tour for the step\n     * @param {object} options The options for the step\n     * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.\n     * @param {object} options.attachTo The element the step should be attached to on the page.\n     * An object with properties `element` and `on`.\n     *\n     * ```js\n     * const step = new Step(tour, {\n     *   attachTo: { element: '.some .selector-path', on: 'left' },\n     *   ...moreOptions\n     * });\n     * ```\n     *\n     * If you don’t specify an `attachTo` the element will appear in the middle of the screen. The same will happen if your `attachTo.element` callback returns `null`, `undefined`, or a selector that does not exist in the DOM.\n     * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n     * in the middle of the screen, without an arrow pointing to the target.\n     * If the element to highlight does not yet exist while instantiating tour steps, you may use lazy evaluation by supplying a function to `attachTo.element`. The function will be called in the `before-show` phase.\n     * @param {string|HTMLElement|function} options.attachTo.element An element selector string, DOM element, or a function (returning a selector, a DOM element, `null` or `undefined`).\n     * @param {string} options.attachTo.on The optional direction to place the FloatingUI tooltip relative to the element.\n     *   - Possible string values: 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end'\n     * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.\n     * It should be an object with a string `selector` and an `event` name\n     * ```js\n     * const step = new Step(tour, {\n     *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n     *   ...moreOptions\n     * });\n     * ```\n     * `event` doesn’t have to be an event inside the tour, it can be any event fired on any element on the page.\n     * You can also always manually advance the Tour by calling `myTour.next()`.\n     * @param {function} options.beforeShowPromise A function that returns a promise.\n     * When the promise resolves, the rest of the `show` code for the step will execute.\n     * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n     * footer below the main body text.\n     * @param {function} options.buttons.button.action A function executed when the button is clicked on.\n     * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n     * work inside the action.\n     * You can use action to skip steps or navigate to specific steps, with something like:\n     * ```js\n     * action() {\n     *   return this.show('some_step_name');\n     * }\n     * ```\n     * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n     * @param {boolean} options.buttons.button.disabled Should the button be disabled?\n     * @param {string} options.buttons.button.label The aria-label text of the button\n     * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button\n     * @param {string} options.buttons.button.text The HTML text of the button\n     * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target\n     * @param {object} options.cancelIcon Options for the cancel icon\n     * @param {boolean} options.cancelIcon.enabled Should a cancel “✕” be shown in the header of the step?\n     * @param {string} options.cancelIcon.label The label to add for `aria-label`\n     * @param {string} options.classes A string of extra classes to add to the step's content element.\n     * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n     * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n     * @param {string} options.id The string to use as the `id` for the step.\n     * @param {number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n     * @param {number | { topLeft: number, bottomLeft: number, bottomRight: number, topRight: number }} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n     * @param {object} options.floatingUIOptions Extra options to pass to FloatingUI\n     * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n     * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n     * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n     * define a custom action to do the scrolling, and possibly other logic.\n     * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n     * If it returns false, the step will be skipped.\n     * @param {string} options.text The text in the body of the step. It can be one of three types:\n     * ```\n     * - HTML string\n     * - `HTMLElement` object\n     * - `Function` to be executed when the step is built. It must return one the two options above.\n     * ```\n     * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:\n     * ```\n     * - HTML string\n     * - `Function` to be executed when the step is built. It must return HTML string.\n     * ```\n     * @param {object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n     * ```js\n     * when: {\n     *   show: function() {\n     *     window.scrollTo(0, 0);\n     *   }\n     * }\n     * ```\n     * @return {Step} The newly created Step instance\n     */\n    function Step(tour, options) {\n      var _this12;\n      _classCallCheck(this, Step);\n      if (options === void 0) {\n        options = {};\n      }\n      _this12 = _super9.call(this, tour, options);\n      _this12.tour = tour;\n      _this12.classPrefix = _this12.tour.options ? normalizePrefix(_this12.tour.options.classPrefix) : '';\n      _this12.styles = tour.styles;\n\n      /**\n       * Resolved attachTo options. Due to lazy evaluation, we only resolve the options during `before-show` phase.\n       * Do not use this directly, use the _getResolvedAttachToOptions method instead.\n       * @type {null|{}|{element, to}}\n       * @private\n       */\n      _this12._resolvedAttachTo = null;\n      autoBind(_assertThisInitialized(_this12));\n      _this12._setOptions(options);\n      return _possibleConstructorReturn(_this12, _assertThisInitialized(_this12));\n    }\n\n    /**\n     * Cancel the tour\n     * Triggers the `cancel` event\n     */\n    _createClass(Step, [{\n      key: \"cancel\",\n      value: function cancel() {\n        this.tour.cancel();\n        this.trigger('cancel');\n      }\n\n      /**\n       * Complete the tour\n       * Triggers the `complete` event\n       */\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.tour.complete();\n        this.trigger('complete');\n      }\n\n      /**\n       * Remove the step, delete the step's element, and destroy the FloatingUI instance for the step.\n       * Triggers `destroy` event\n       */\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        destroyTooltip(this);\n        if (isHTMLElement$1(this.el)) {\n          this.el.remove();\n          this.el = null;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('destroy');\n      }\n\n      /**\n       * Returns the tour for the step\n       * @return {Tour} The tour instance\n       */\n    }, {\n      key: \"getTour\",\n      value: function getTour() {\n        return this.tour;\n      }\n\n      /**\n       * Hide the step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.tour.modal.hide();\n        this.trigger('before-hide');\n        if (this.el) {\n          this.el.hidden = true;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('hide');\n      }\n\n      /**\n       * Resolves attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_resolveAttachToOptions\",\n      value: function _resolveAttachToOptions() {\n        this._resolvedAttachTo = parseAttachTo(this);\n        return this._resolvedAttachTo;\n      }\n\n      /**\n       * A selector for resolved attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_getResolvedAttachToOptions\",\n      value: function _getResolvedAttachToOptions() {\n        if (this._resolvedAttachTo === null) {\n          return this._resolveAttachToOptions();\n        }\n        return this._resolvedAttachTo;\n      }\n\n      /**\n       * Check if the step is open and visible\n       * @return {boolean} True if the step is open and visible\n       */\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return Boolean(this.el && !this.el.hidden);\n      }\n\n      /**\n       * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n       * @return {*|Promise}\n       */\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this13 = this;\n        if (isFunction(this.options.beforeShowPromise)) {\n          return Promise.resolve(this.options.beforeShowPromise()).then(function () {\n            return _this13._show();\n          });\n        }\n        return Promise.resolve(this._show());\n      }\n\n      /**\n       * Updates the options of the step.\n       *\n       * @param {Object} options The options for the step\n       */\n    }, {\n      key: \"updateStepOptions\",\n      value: function updateStepOptions(options) {\n        Object.assign(this.options, options);\n        if (this.shepherdElementComponent) {\n          this.shepherdElementComponent.$set({\n            step: this\n          });\n        }\n      }\n\n      /**\n       * Returns the element for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n       */\n    }, {\n      key: \"getElement\",\n      value: function getElement() {\n        return this.el;\n      }\n\n      /**\n       * Returns the target for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n       */\n    }, {\n      key: \"getTarget\",\n      value: function getTarget() {\n        return this.target;\n      }\n\n      /**\n       * Creates Shepherd element for step based on options\n       *\n       * @return {Element} The DOM element for the step tooltip\n       * @private\n       */\n    }, {\n      key: \"_createTooltipContent\",\n      value: function _createTooltipContent() {\n        var descriptionId = \"\".concat(this.id, \"-description\");\n        var labelId = \"\".concat(this.id, \"-label\");\n        this.shepherdElementComponent = new Shepherd_element({\n          target: this.tour.options.stepsContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            descriptionId: descriptionId,\n            labelId: labelId,\n            step: this,\n            styles: this.styles\n          }\n        });\n        return this.shepherdElementComponent.getElement();\n      }\n\n      /**\n       * If a custom scrollToHandler is defined, call that, otherwise do the generic\n       * scrollIntoView call.\n       *\n       * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n       * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n       * @private\n       */\n    }, {\n      key: \"_scrollTo\",\n      value: function _scrollTo(scrollToOptions) {\n        var _this$_getResolvedAtt = this._getResolvedAttachToOptions(),\n          element = _this$_getResolvedAtt.element;\n        if (isFunction(this.options.scrollToHandler)) {\n          this.options.scrollToHandler(element);\n        } else if (isElement$1(element) && typeof element.scrollIntoView === 'function') {\n          element.scrollIntoView(scrollToOptions);\n        }\n      }\n\n      /**\n       * _getClassOptions gets all possible classes for the step\n       * @param {Object} stepOptions The step specific options\n       * @returns {String} unique string from array of classes\n       * @private\n       */\n    }, {\n      key: \"_getClassOptions\",\n      value: function _getClassOptions(stepOptions) {\n        var defaultStepOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        var stepClasses = stepOptions.classes ? stepOptions.classes : '';\n        var defaultStepOptionsClasses = defaultStepOptions && defaultStepOptions.classes ? defaultStepOptions.classes : '';\n        var allClasses = [].concat(_toConsumableArray(stepClasses.split(' ')), _toConsumableArray(defaultStepOptionsClasses.split(' ')));\n        var uniqClasses = new Set(allClasses);\n        return Array.from(uniqClasses).join(' ').trim();\n      }\n\n      /**\n       * Sets the options for the step, maps `when` to events, sets up buttons\n       * @param {Object} options The options for the step\n       * @private\n       */\n    }, {\n      key: \"_setOptions\",\n      value: function _setOptions(options) {\n        var _this14 = this;\n        if (options === void 0) {\n          options = {};\n        }\n        var tourOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        tourOptions = cjs({}, tourOptions || {});\n        this.options = Object.assign({\n          arrow: true\n        }, tourOptions, options, mergeTooltipConfig(tourOptions, options));\n        var when = this.options.when;\n        this.options.classes = this._getClassOptions(options);\n        this.destroy();\n        this.id = this.options.id || \"step-\".concat(uuid());\n        if (when) {\n          Object.keys(when).forEach(function (event) {\n            _this14.on(event, when[event], _this14);\n          });\n        }\n      }\n\n      /**\n       * Create the element and set up the FloatingUI instance\n       * @private\n       */\n    }, {\n      key: \"_setupElements\",\n      value: function _setupElements() {\n        if (!isUndefined(this.el)) {\n          this.destroy();\n        }\n        this.el = this._createTooltipContent();\n        if (this.options.advanceOn) {\n          bindAdvance(this);\n        }\n\n        // The tooltip implementation details are handled outside of the Step\n        // object.\n        setupTooltip(this);\n      }\n\n      /**\n       * Triggers `before-show`, generates the tooltip DOM content,\n       * sets up a FloatingUI instance for the tooltip, then triggers `show`.\n       * @private\n       */\n    }, {\n      key: \"_show\",\n      value: function _show() {\n        var _this15 = this;\n        this.trigger('before-show');\n\n        // Force resolve to make sure the options are updated on subsequent shows.\n        this._resolveAttachToOptions();\n        this._setupElements();\n        if (!this.tour.modal) {\n          this.tour._setupModal();\n        }\n        this.tour.modal.setupForStep(this);\n        this._styleTargetElementForStep(this);\n        this.el.hidden = false;\n\n        // start scrolling to target before showing the step\n        if (this.options.scrollTo) {\n          setTimeout(function () {\n            _this15._scrollTo(_this15.options.scrollTo);\n          });\n        }\n        this.el.hidden = false;\n        var content = this.shepherdElementComponent.getElement();\n        var target = this.target || document.body;\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-enabled\"));\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-target\"));\n        content.classList.add('shepherd-enabled');\n        this.trigger('show');\n      }\n\n      /**\n       * Modulates the styles of the passed step's target element, based on the step's options and\n       * the tour's `modal` option, to visually emphasize the element\n       *\n       * @param step The step object that attaches to the element\n       * @private\n       */\n    }, {\n      key: \"_styleTargetElementForStep\",\n      value: function _styleTargetElementForStep(step) {\n        var targetElement = step.target;\n        if (!targetElement) {\n          return;\n        }\n        if (step.options.highlightClass) {\n          targetElement.classList.add(step.options.highlightClass);\n        }\n        targetElement.classList.remove('shepherd-target-click-disabled');\n        if (step.options.canClickTarget === false) {\n          targetElement.classList.add('shepherd-target-click-disabled');\n        }\n      }\n\n      /**\n       * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n       * and 'shepherd-target' classes\n       * @private\n       */\n    }, {\n      key: \"_updateStepTargetOnHide\",\n      value: function _updateStepTargetOnHide() {\n        var target = this.target || document.body;\n        if (this.options.highlightClass) {\n          target.classList.remove(this.options.highlightClass);\n        }\n        target.classList.remove('shepherd-target-click-disabled', \"\".concat(this.classPrefix, \"shepherd-enabled\"), \"\".concat(this.classPrefix, \"shepherd-target\"));\n      }\n    }]);\n    return Step;\n  }(Evented);\n  /**\n   * Cleanup the steps and set pointerEvents back to 'auto'\n   * @param tour The tour object\n   */\n  function cleanupSteps(tour) {\n    if (tour) {\n      var steps = tour.steps;\n      steps.forEach(function (step) {\n        if (step.options && step.options.canClickTarget === false && step.options.attachTo) {\n          if (step.target instanceof HTMLElement) {\n            step.target.classList.remove('shepherd-target-click-disabled');\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Generates the svg path data for a rounded rectangle overlay\n   * @param {Object} dimension - Dimensions of rectangle.\n   * @param {number} width - Width.\n   * @param {number} height - Height.\n   * @param {number} [x=0] - Offset from top left corner in x axis. default 0.\n   * @param {number} [y=0] - Offset from top left corner in y axis. default 0.\n   * @param {number | { topLeft: number, topRight: number, bottomRight: number, bottomLeft: number }} [r=0] - Corner Radius. Keep this smaller than half of width or height.\n   * @returns {string} - Rounded rectangle overlay path data.\n   */\n  function makeOverlayPath(_ref) {\n    var width = _ref.width,\n      height = _ref.height,\n      _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y,\n      _ref$r = _ref.r,\n      r = _ref$r === void 0 ? 0 : _ref$r;\n    var _window = window,\n      w = _window.innerWidth,\n      h = _window.innerHeight;\n    var _ref15 = typeof r === 'number' ? {\n        topLeft: r,\n        topRight: r,\n        bottomRight: r,\n        bottomLeft: r\n      } : r,\n      _ref15$topLeft = _ref15.topLeft,\n      topLeft = _ref15$topLeft === void 0 ? 0 : _ref15$topLeft,\n      _ref15$topRight = _ref15.topRight,\n      topRight = _ref15$topRight === void 0 ? 0 : _ref15$topRight,\n      _ref15$bottomRight = _ref15.bottomRight,\n      bottomRight = _ref15$bottomRight === void 0 ? 0 : _ref15$bottomRight,\n      _ref15$bottomLeft = _ref15.bottomLeft,\n      bottomLeft = _ref15$bottomLeft === void 0 ? 0 : _ref15$bottomLeft;\n    return \"M\".concat(w, \",\").concat(h, \"H0V0H\").concat(w, \"V\").concat(h, \"ZM\").concat(x + topLeft, \",\").concat(y, \"a\").concat(topLeft, \",\").concat(topLeft, \",0,0,0-\").concat(topLeft, \",\").concat(topLeft, \"V\").concat(height + y - bottomLeft, \"a\").concat(bottomLeft, \",\").concat(bottomLeft, \",0,0,0,\").concat(bottomLeft, \",\").concat(bottomLeft, \"H\").concat(width + x - bottomRight, \"a\").concat(bottomRight, \",\").concat(bottomRight, \",0,0,0,\").concat(bottomRight, \"-\").concat(bottomRight, \"V\").concat(y + topRight, \"a\").concat(topRight, \",\").concat(topRight, \",0,0,0-\").concat(topRight, \"-\").concat(topRight, \"Z\");\n  }\n\n  /* src/js/components/shepherd-modal.svelte generated by Svelte v3.58.0 */\n  function create_fragment(ctx) {\n    var svg;\n    var path;\n    var svg_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        svg = svg_element(\"svg\");\n        path = svg_element(\"path\");\n        attr(path, \"d\", /*pathDefinition*/ctx[2]);\n        attr(svg, \"class\", svg_class_value = \"\".concat( /*modalIsVisible*/ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"));\n      },\n      m: function m(target, anchor) {\n        insert(target, svg, anchor);\n        append(svg, path);\n        /*svg_binding*/\n        ctx[11](svg);\n        if (!mounted) {\n          dispose = listen(svg, \"touchmove\", /*_preventModalOverlayTouch*/ctx[3]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref16 = _slicedToArray(_ref, 1),\n          dirty = _ref16[0];\n        if (dirty & /*pathDefinition*/4) {\n          attr(path, \"d\", /*pathDefinition*/ctx[2]);\n        }\n        if (dirty & /*modalIsVisible*/2 && svg_class_value !== (svg_class_value = \"\".concat( /*modalIsVisible*/ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"))) {\n          attr(svg, \"class\", svg_class_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(svg);\n        /*svg_binding*/\n        ctx[11](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n    var isHtmlElement = element instanceof HTMLElement;\n    var overflowY = isHtmlElement && window.getComputedStyle(element).overflowY;\n    var isScrollable = overflowY !== 'hidden' && overflowY !== 'visible';\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n    return _getScrollParent(element.parentElement);\n  }\n\n  /**\n   * Get the visible height of the target element relative to its scrollParent.\n   * If there is no scroll parent, the height of the element is returned.\n   *\n   * @param {HTMLElement} element The target element\n   * @param {HTMLElement} [scrollParent] The scrollable parent element\n   * @returns {{y: number, height: number}}\n   * @private\n   */\n  function _getVisibleHeight(element, scrollParent) {\n    var elementRect = element.getBoundingClientRect();\n    var top = elementRect.y || elementRect.top;\n    var bottom = elementRect.bottom || top + elementRect.height;\n    if (scrollParent) {\n      var scrollRect = scrollParent.getBoundingClientRect();\n      var scrollTop = scrollRect.y || scrollRect.top;\n      var scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n    var height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n    return {\n      y: top,\n      height: height\n    };\n  }\n  function instance($$self, $$props, $$invalidate) {\n    var element = $$props.element,\n      openingProperties = $$props.openingProperties;\n    uuid();\n    var modalIsVisible = false;\n    var rafId = undefined;\n    var pathDefinition;\n    closeModalOpening();\n    var getElement = function getElement() {\n      return element;\n    };\n    function closeModalOpening() {\n      $$invalidate(4, openingProperties = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0,\n        r: 0\n      });\n    }\n    function hide() {\n      $$invalidate(1, modalIsVisible = false);\n\n      // Ensure we cleanup all event listeners when we hide the modal\n      _cleanupStepEventListeners();\n    }\n    function positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, targetElement) {\n      if (modalOverlayOpeningPadding === void 0) {\n        modalOverlayOpeningPadding = 0;\n      }\n      if (modalOverlayOpeningRadius === void 0) {\n        modalOverlayOpeningRadius = 0;\n      }\n      if (targetElement) {\n        var _getVisibleHeight2 = _getVisibleHeight(targetElement, scrollParent),\n          y = _getVisibleHeight2.y,\n          height = _getVisibleHeight2.height;\n        var _targetElement$getBou = targetElement.getBoundingClientRect(),\n          x = _targetElement$getBou.x,\n          width = _targetElement$getBou.width,\n          left = _targetElement$getBou.left;\n\n        // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n        $$invalidate(4, openingProperties = {\n          width: width + modalOverlayOpeningPadding * 2,\n          height: height + modalOverlayOpeningPadding * 2,\n          x: (x || left) - modalOverlayOpeningPadding,\n          y: y - modalOverlayOpeningPadding,\n          r: modalOverlayOpeningRadius\n        });\n      } else {\n        closeModalOpening();\n      }\n    }\n    function setupForStep(step) {\n      // Ensure we move listeners from the previous step, before we setup new ones\n      _cleanupStepEventListeners();\n      if (step.tour.options.useModalOverlay) {\n        _styleForStep(step);\n        show();\n      } else {\n        hide();\n      }\n    }\n    function show() {\n      $$invalidate(1, modalIsVisible = true);\n    }\n    var _preventModalBodyTouch = function _preventModalBodyTouch(e) {\n      e.preventDefault();\n    };\n    var _preventModalOverlayTouch = function _preventModalOverlayTouch(e) {\n      e.stopPropagation();\n    };\n\n    /**\n    * Add touchmove event listener\n    * @private\n    */\n    function _addStepEventListeners() {\n      // Prevents window from moving on touch.\n      window.addEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n\n    /**\n    * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n    * @private\n    */\n    function _cleanupStepEventListeners() {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n        rafId = undefined;\n      }\n      window.removeEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n\n    /**\n    * Style the modal for the step\n    * @param {Step} step The step to style the opening for\n    * @private\n    */\n    function _styleForStep(step) {\n      var _step$options = step.options,\n        modalOverlayOpeningPadding = _step$options.modalOverlayOpeningPadding,\n        modalOverlayOpeningRadius = _step$options.modalOverlayOpeningRadius;\n      var scrollParent = _getScrollParent(step.target);\n\n      // Setup recursive function to call requestAnimationFrame to update the modal opening position\n      var rafLoop = function rafLoop() {\n        rafId = undefined;\n        positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, step.target);\n        rafId = requestAnimationFrame(rafLoop);\n      };\n      rafLoop();\n      _addStepEventListeners();\n    }\n    function svg_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('openingProperties' in $$props) $$invalidate(4, openingProperties = $$props.openingProperties);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*openingProperties*/16) {\n        $$invalidate(2, pathDefinition = makeOverlayPath(openingProperties));\n      }\n    };\n    return [element, modalIsVisible, pathDefinition, _preventModalOverlayTouch, openingProperties, getElement, closeModalOpening, hide, positionModal, setupForStep, show, svg_binding];\n  }\n  var Shepherd_modal = /*#__PURE__*/function (_SvelteComponent9) {\n    _inherits(Shepherd_modal, _SvelteComponent9);\n    var _super10 = _createSuper(Shepherd_modal);\n    function Shepherd_modal(options) {\n      var _this16;\n      _classCallCheck(this, Shepherd_modal);\n      _this16 = _super10.call(this);\n      init(_assertThisInitialized(_this16), options, instance, create_fragment, safe_not_equal, {\n        element: 0,\n        openingProperties: 4,\n        getElement: 5,\n        closeModalOpening: 6,\n        hide: 7,\n        positionModal: 8,\n        setupForStep: 9,\n        show: 10\n      });\n      return _this16;\n    }\n    _createClass(Shepherd_modal, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[5];\n      }\n    }, {\n      key: \"closeModalOpening\",\n      get: function get() {\n        return this.$$.ctx[6];\n      }\n    }, {\n      key: \"hide\",\n      get: function get() {\n        return this.$$.ctx[7];\n      }\n    }, {\n      key: \"positionModal\",\n      get: function get() {\n        return this.$$.ctx[8];\n      }\n    }, {\n      key: \"setupForStep\",\n      get: function get() {\n        return this.$$.ctx[9];\n      }\n    }, {\n      key: \"show\",\n      get: function get() {\n        return this.$$.ctx[10];\n      }\n    }]);\n    return Shepherd_modal;\n  }(SvelteComponent);\n  var Shepherd = new Evented();\n\n  /**\n   * Class representing the site tour\n   * @extends {Evented}\n   */\n  var Tour = /*#__PURE__*/function (_Evented2) {\n    _inherits(Tour, _Evented2);\n    var _super11 = _createSuper(Tour);\n    /**\n     * @param {Object} options The options for the tour\n     * @param {boolean | function(): boolean | Promise<boolean> | function(): Promise<boolean>} options.confirmCancel If true, will issue a `window.confirm` before cancelling.\n     * If it is a function(support Async Function), it will be called and wait for the return value, and will only be cancelled if the value returned is true\n     * @param {string} options.confirmCancelMessage The message to display in the `window.confirm` dialog\n     * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n     * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n     * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly\n     * set to false.\n     * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled\n     * unless this is explicitly set to false.\n     * @param {HTMLElement} options.stepsContainer An optional container element for the steps.\n     * If not set, the steps will be appended to `document.body`.\n     * @param {HTMLElement} options.modalContainer An optional container element for the modal.\n     * If not set, the modal will be appended to `document.body`.\n     * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with\n     * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n     * dynamically generated `id` property.\n     * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n     * modal overlay. If true, the overlay will create an opening around the target element so that it\n     * can remain interactive\n     * @returns {Tour}\n     */\n    function Tour(options) {\n      var _this17;\n      _classCallCheck(this, Tour);\n      if (options === void 0) {\n        options = {};\n      }\n      _this17 = _super11.call(this, options);\n      autoBind(_assertThisInitialized(_this17));\n      var defaultTourOptions = {\n        exitOnEsc: true,\n        keyboardNavigation: true\n      };\n      _this17.options = Object.assign({}, defaultTourOptions, options);\n      _this17.classPrefix = normalizePrefix(_this17.options.classPrefix);\n      _this17.steps = [];\n      _this17.addSteps(_this17.options.steps);\n\n      // Pass these events onto the global Shepherd object\n      var events = ['active', 'cancel', 'complete', 'inactive', 'show', 'start'];\n      events.map(function (event) {\n        (function (e) {\n          _this17.on(e, function (opts) {\n            opts = opts || {};\n            opts.tour = _assertThisInitialized(_this17);\n            Shepherd.trigger(e, opts);\n          });\n        })(event);\n      });\n      _this17._setTourID();\n      return _possibleConstructorReturn(_this17, _assertThisInitialized(_this17));\n    }\n\n    /**\n     * Adds a new step to the tour\n     * @param {Object|Step} options An object containing step options or a Step instance\n     * @param {number} index The optional index to insert the step at. If undefined, the step\n     * is added to the end of the array.\n     * @return {Step} The newly added step\n     */\n    _createClass(Tour, [{\n      key: \"addStep\",\n      value: function addStep(options, index) {\n        var step = options;\n        if (!(step instanceof Step)) {\n          step = new Step(this, step);\n        } else {\n          step.tour = this;\n        }\n        if (!isUndefined(index)) {\n          this.steps.splice(index, 0, step);\n        } else {\n          this.steps.push(step);\n        }\n        return step;\n      }\n\n      /**\n       * Add multiple steps to the tour\n       * @param {Array<object> | Array<Step>} steps The steps to add to the tour\n       */\n    }, {\n      key: \"addSteps\",\n      value: function addSteps(steps) {\n        var _this18 = this;\n        if (Array.isArray(steps)) {\n          steps.forEach(function (step) {\n            _this18.addStep(step);\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Go to the previous step in the tour\n       */\n    }, {\n      key: \"back\",\n      value: function back() {\n        var index = this.steps.indexOf(this.currentStep);\n        this.show(index - 1, false);\n      }\n\n      /**\n       * Calls _done() triggering the 'cancel' event\n       * If `confirmCancel` is true, will show a window.confirm before cancelling\n       * If `confirmCancel` is a function, will call it and wait for the return value,\n       * and only cancel when the value returned is true\n       */\n    }, {\n      key: \"cancel\",\n      value: function () {\n        var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n          var confirmCancelIsFunction, cancelMessage, stopTour;\n          return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n            while (1) switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!this.options.confirmCancel) {\n                  _context6.next = 14;\n                  break;\n                }\n                confirmCancelIsFunction = typeof this.options.confirmCancel === 'function';\n                cancelMessage = this.options.confirmCancelMessage || 'Are you sure you want to stop the tour?';\n                if (!confirmCancelIsFunction) {\n                  _context6.next = 9;\n                  break;\n                }\n                _context6.next = 6;\n                return this.options.confirmCancel();\n              case 6:\n                _context6.t0 = _context6.sent;\n                _context6.next = 10;\n                break;\n              case 9:\n                _context6.t0 = window.confirm(cancelMessage);\n              case 10:\n                stopTour = _context6.t0;\n                if (stopTour) {\n                  this._done('cancel');\n                }\n                _context6.next = 15;\n                break;\n              case 14:\n                this._done('cancel');\n              case 15:\n              case \"end\":\n                return _context6.stop();\n            }\n          }, _callee6, this);\n        }));\n        function cancel() {\n          return _cancel.apply(this, arguments);\n        }\n        return cancel;\n      }()\n      /**\n       * Calls _done() triggering the `complete` event\n       */\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this._done('complete');\n      }\n\n      /**\n       * Gets the step from a given id\n       * @param {Number|String} id The id of the step to retrieve\n       * @return {Step} The step corresponding to the `id`\n       */\n    }, {\n      key: \"getById\",\n      value: function getById(id) {\n        return this.steps.find(function (step) {\n          return step.id === id;\n        });\n      }\n\n      /**\n       * Gets the current step\n       * @returns {Step|null}\n       */\n    }, {\n      key: \"getCurrentStep\",\n      value: function getCurrentStep() {\n        return this.currentStep;\n      }\n\n      /**\n       * Hide the current step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var currentStep = this.getCurrentStep();\n        if (currentStep) {\n          return currentStep.hide();\n        }\n      }\n\n      /**\n       * Check if the tour is active\n       * @return {boolean}\n       */\n    }, {\n      key: \"isActive\",\n      value: function isActive() {\n        return Shepherd.activeTour === this;\n      }\n\n      /**\n       * Go to the next step in the tour\n       * If we are at the end, call `complete`\n       */\n    }, {\n      key: \"next\",\n      value: function next() {\n        var index = this.steps.indexOf(this.currentStep);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          this.show(index + 1, true);\n        }\n      }\n\n      /**\n       * Removes the step from the tour\n       * @param {String} name The id for the step to remove\n       */\n    }, {\n      key: \"removeStep\",\n      value: function removeStep(name) {\n        var _this19 = this;\n        var current = this.getCurrentStep();\n\n        // Find the step, destroy it and remove it from this.steps\n        this.steps.some(function (step, i) {\n          if (step.id === name) {\n            if (step.isOpen()) {\n              step.hide();\n            }\n            step.destroy();\n            _this19.steps.splice(i, 1);\n            return true;\n          }\n        });\n        if (current && current.id === name) {\n          this.currentStep = undefined;\n\n          // If we have steps left, show the first one, otherwise just cancel the tour\n          this.steps.length ? this.show(0) : this.cancel();\n        }\n      }\n\n      /**\n       * Show a specific step in the tour\n       * @param {Number|String} key The key to look up the step by\n       * @param {Boolean} forward True if we are going forward, false if backward\n       */\n    }, {\n      key: \"show\",\n      value: function show(key, forward) {\n        if (key === void 0) {\n          key = 0;\n        }\n        if (forward === void 0) {\n          forward = true;\n        }\n        var step = isString(key) ? this.getById(key) : this.steps[key];\n        if (step) {\n          this._updateStateBeforeShow();\n          var shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn();\n\n          // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n          if (shouldSkipStep) {\n            this._skipStep(step, forward);\n          } else {\n            this.trigger('show', {\n              step: step,\n              previous: this.currentStep\n            });\n            this.currentStep = step;\n            step.show();\n          }\n        }\n      }\n\n      /**\n       * Start the tour\n       */\n    }, {\n      key: \"start\",\n      value: function start() {\n        this.trigger('start');\n\n        // Save the focused element before the tour opens\n        this.focusedElBeforeOpen = document.activeElement;\n        this.currentStep = null;\n        this._setupModal();\n        this._setupActiveTour();\n        this.next();\n      }\n\n      /**\n       * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n       * @param {String} event The event name to trigger\n       * @private\n       */\n    }, {\n      key: \"_done\",\n      value: function _done(event) {\n        var index = this.steps.indexOf(this.currentStep);\n        if (Array.isArray(this.steps)) {\n          this.steps.forEach(function (step) {\n            return step.destroy();\n          });\n        }\n        cleanupSteps(this);\n        this.trigger(event, {\n          index: index\n        });\n        Shepherd.activeTour = null;\n        this.trigger('inactive', {\n          tour: this\n        });\n        if (this.modal) {\n          this.modal.hide();\n        }\n        if (event === 'cancel' || event === 'complete') {\n          if (this.modal) {\n            var modalContainer = document.querySelector('.shepherd-modal-overlay-container');\n            if (modalContainer) {\n              modalContainer.remove();\n            }\n          }\n        }\n\n        // Focus the element that was focused before the tour started\n        if (isHTMLElement$1(this.focusedElBeforeOpen)) {\n          this.focusedElBeforeOpen.focus();\n        }\n      }\n\n      /**\n       * Make this tour \"active\"\n       * @private\n       */\n    }, {\n      key: \"_setupActiveTour\",\n      value: function _setupActiveTour() {\n        this.trigger('active', {\n          tour: this\n        });\n        Shepherd.activeTour = this;\n      }\n\n      /**\n       * _setupModal create the modal container and instance\n       * @private\n       */\n    }, {\n      key: \"_setupModal\",\n      value: function _setupModal() {\n        this.modal = new Shepherd_modal({\n          target: this.options.modalContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            styles: this.styles\n          }\n        });\n      }\n\n      /**\n       * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step\n       * @param {Step} step The step to skip\n       * @param {Boolean} forward True if we are going forward, false if backward\n       * @private\n       */\n    }, {\n      key: \"_skipStep\",\n      value: function _skipStep(step, forward) {\n        var index = this.steps.indexOf(step);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          var nextIndex = forward ? index + 1 : index - 1;\n          this.show(nextIndex, forward);\n        }\n      }\n\n      /**\n       * Before showing, hide the current step and if the tour is not\n       * already active, call `this._setupActiveTour`.\n       * @private\n       */\n    }, {\n      key: \"_updateStateBeforeShow\",\n      value: function _updateStateBeforeShow() {\n        if (this.currentStep) {\n          this.currentStep.hide();\n        }\n        if (!this.isActive()) {\n          this._setupActiveTour();\n        }\n      }\n\n      /**\n       * Sets this.id to `${tourName}--${uuid}`\n       * @private\n       */\n    }, {\n      key: \"_setTourID\",\n      value: function _setTourID() {\n        var tourName = this.options.tourName || 'tour';\n        this.id = \"\".concat(tourName, \"--\").concat(uuid());\n      }\n    }]);\n    return Tour;\n  }(Evented);\n  var isServerSide = typeof window === 'undefined';\n  var NoOp = /*#__PURE__*/_createClass(function NoOp() {\n    _classCallCheck(this, NoOp);\n  });\n  if (isServerSide) {\n    Object.assign(Shepherd, {\n      Tour: NoOp,\n      Step: NoOp\n    });\n  } else {\n    Object.assign(Shepherd, {\n      Tour: Tour,\n      Step: Step\n    });\n  }\n  return Shepherd;\n});\n\n//# sourceURL=webpack://Vuexy/./node_modules/shepherd.js/dist/js/shepherd.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/shepherd/shepherd.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});