<?php

namespace App\Imports\Administration\Inventory;

use App\Models\Inventory\Inventory;
use App\Models\Inventory\InventoryCategory;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;
use Maatwebsite\Excel\Concerns\ToCollection;
use Maatwebsite\Excel\Concerns\WithHeadingRow;
use Maatwebsite\Excel\Concerns\WithValidation;
use Exception;

class InventoryImport implements ToCollection, WithHeadingRow, WithValidation
{
    /**
     * @param Collection $rows
     */
    public function collection(Collection $rows)
    {
        foreach ($rows as $rowIndex => $row) {
            try {
                // Clean and validate row data
                $cleanedRow = $this->cleanRowData($row);

                // Skip rows with missing required data
                if (!$this->isRowValid($cleanedRow)) {
                    continue;
                }

                // Get quantity
                $quantity = (int)($cleanedRow['quantity'] ?? 1);

                DB::transaction(function () use ($cleanedRow, $quantity) {
                    // Get or create category (prevent duplicates)
                    $category = $this->getOrCreateCategory($cleanedRow['category']);

                    // Create multiple inventory items based on quantity
                    for ($i = 0; $i < $quantity; $i++) {
                        $this->createInventoryItem($cleanedRow, $category, $i + 1, $quantity);
                    }
                });
            } catch (Exception $e) {
                dd('Error: ' . $e->getMessage());
            }
        }
    }

    /**
     * Get or create category to prevent duplicates
     */
    protected function getOrCreateCategory(string $categoryName): InventoryCategory
    {
        $category = InventoryCategory::firstOrCreate(
            ['name' => trim($categoryName)],
            [
                'name' => trim($categoryName),
                'description' => 'Imported from CSV - ' . trim($categoryName),
                'creator_id' => auth()->id() ?? 1,
            ]
        );

        return $category;
    }

    /**
     * Create a single inventory item
     */
    protected function createInventoryItem(array $row, InventoryCategory $category, int $itemNumber, int $totalQuantity): void
    {
        // Generate unique number for this item
        $uniqueNumber = $this->generateUniqueNumber($row['unique_number'], $itemNumber, $totalQuantity);

        // Check if inventory with this unique number already exists
        $existingInventory = Inventory::where('unique_number', $uniqueNumber)
            ->where('name', $row['name'])
            ->first();

        if ($existingInventory) {
            // Skip if already exists
            return;
        }

        // Create the inventory item
        Inventory::create([
            'category_id' => $category->id,
            'creator_id' => auth()->id() ?? 1,
            'name' => $row['name'] ?? 'Unknown Product',
            'unique_number' => $uniqueNumber,
            'description' => $row['description'] ?? '',
            'price' => (float)($row['price'] ?? 0),
            'status' => $this->mapStatus($row['status'] ?? 'Available'),
            'usage_for' => $row['usage_for'] ?? '',
            // office_inventory_code will be auto-generated by the model
        ]);
    }

    /**
     * Generate unique number for inventory items
     */
    protected function generateUniqueNumber(?string $baseUniqueNumber, int $itemNumber, int $totalQuantity): ?string
    {
        if (empty($baseUniqueNumber)) {
            return null;
        }

        // If quantity is 1, use the original unique number
        if ($totalQuantity == 1) {
            return $baseUniqueNumber;
        }

        // If quantity > 1, append item number to make it unique
        return $baseUniqueNumber . '-' . $itemNumber;
    }

    /**
     * Map status from CSV to inventory status
     */
    protected function mapStatus(string $status): string
    {
        $statusMap = [
            'available' => 'Available',
            'in use' => 'In Use',
            'out of service' => 'Out of Service',
            'damaged' => 'Damaged',
        ];

        $normalizedStatus = strtolower(trim($status));

        return $statusMap[$normalizedStatus] ?? 'Available';
    }

    /**
     * Clean and sanitize row data
     */
    protected function cleanRowData($row): array
    {
        return [
            'category' => trim($row['category'] ?? ''),
            'name' => trim($row['name'] ?? ''),
            'unique_number' => $this->cleanUniqueNumber($row['unique_number'] ?? ''),
            'price' => $row['price'] ?? 0,
            'description' => trim($row['description'] ?? ''),
            'usage_for' => trim($row['usage_for'] ?? ''),
            'status' => trim($row['status'] ?? 'Available'),
            'quantity' => $row['quantity'] ?? 1,
        ];
    }

    /**
     * Clean unique number field - convert to string if needed
     */
    protected function cleanUniqueNumber($uniqueNumber): ?string
    {
        if (empty($uniqueNumber)) {
            return null;
        }

        // Convert to string and trim
        return trim((string) $uniqueNumber);
    }

    /**
     * Check if row has valid required data
     */
    protected function isRowValid(array $row): bool
    {
        // Check required fields
        if (empty($row['category']) || empty($row['name'])) {
            return false;
        }

        // Check if category and name are not just whitespace
        if (trim($row['category']) === '' || trim($row['name']) === '') {
            return false;
        }

        return true;
    }

    /**
     * Define validation rules for the import.
     */
    public function rules(): array
    {
        return [
            '*.category' => 'required|string|max:255',
            '*.name' => 'required|string|max:255',
            '*.unique_number' => 'nullable|max:255',
            '*.price' => 'nullable|numeric|min:0',
            '*.description' => 'nullable|string',
            '*.usage_for' => 'nullable|string|max:255',
            '*.status' => 'nullable|string|in:Available,In Use,Out of Service,Damaged,available,in use,out of service,damaged',
            '*.quantity' => 'nullable|integer|min:1|max:1000',
        ];
    }

    /**
     * Custom validation messages.
     */
    public function customValidationMessages()
    {
        return [
            '*.category.required' => 'Category is required for all inventory items.',
            '*.name.required' => 'Product name is required for all inventory items.',
            '*.price.numeric' => 'Price must be a valid number.',
            '*.price.min' => 'Price cannot be negative.',
            '*.status.in' => 'Status must be one of: Available, In Use, Out of Service, Damaged.',
            '*.quantity.integer' => 'Quantity must be a whole number.',
            '*.quantity.min' => 'Quantity must be at least 1.',
            '*.quantity.max' => 'Quantity cannot exceed 1000.',
        ];
    }
}
